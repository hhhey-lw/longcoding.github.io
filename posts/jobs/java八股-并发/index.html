<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>LongWei Blog</title>
<meta name="keywords" content="">
<meta name="description" content="1 如何创建多线程
1） 实现Runnable接口

实现run()方法

new Thread(MyRunnable()).start();
2）继承Thread类

重写run()方法

3）Callable接口&amp;&amp;FutureTask">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/jobs/java%E5%85%AB%E8%82%A1-%E5%B9%B6%E5%8F%91/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.488b476fe12f895e41e7473bc23e9831609c74c2bdb368da996800ef083721e1.css" integrity="sha256-SItHb&#43;EviV5B50c7wj6YMWCcdMK9s2jamWgA7wg3IeE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/jobs/java%E5%85%AB%E8%82%A1-%E5%B9%B6%E5%8F%91/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
 <script type="text/javascript"
         async
         src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
 MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$','$'], ['\\(','\\)']],
     displayMath: [['$$','$$'], ['\[\[','\]\]']],
     processEscapes: true,
     processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="LongWei Blog (Alt + H)">LongWei Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="LongWei Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h3 id="1-如何创建多线程">1 如何创建多线程<a hidden class="anchor" aria-hidden="true" href="#1-如何创建多线程">#</a></h3>
<p>1） 实现<strong>Runnable</strong>接口</p>
<ul>
<li>实现run()方法</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">MyRunnable</span><span class="p">()).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>2）继承Thread类</p>
<ul>
<li>重写run()方法</li>
</ul>
<p>3）Callable接口&amp;&amp;FutureTask</p>
<ul>
<li>实现Callable call()方法，使用FutureTask包装Callable对象，通过Thread启动</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">FutrueTask</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FutrueTask</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">MyCallable</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Thread</span><span class="p">(</span><span class="n">task</span><span class="p">).</span><span class="na">start</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ResultType</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这里阻塞</span><span class="w">
</span></span></span></code></pre></div><p>4）使用线程池</p>
<ul>
<li>通过ExecutorService提交Runnable或者Callable任务</li>
</ul>
<p>不同方法对比</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Runnable</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="n">Callable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">Callable</span><span class="p">:</span><span class="n">可以返回结果</span><span class="err">，</span><span class="n">可以抛出异常</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">线程池的优势</span><span class="err">：</span><span class="n">避免重复创建和销毁线程</span><span class="err">，</span><span class="n">减少这部分重复带来的开销</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ThreadPool</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">FixedThreadPool</span><span class="p">,</span><span class="w"> </span><span class="n">CachedThreadPool</span><span class="p">,</span><span class="w"> </span><span class="n">ScheduledThreadPool</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">虚拟线程</span><span class="err">：</span><span class="n">虚拟线程创建和切换开销更低</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Thread</span><span class="p">.</span><span class="na">startVirtualThread</span><span class="p">()</span><span class="w">
</span></span></span></code></pre></div><p><strong>ThreadPool实践</strong></p>
<p>XXXThreadPool.submit(task&hellip;)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nl">FixedThreadPool</span><span class="p">:</span><span class="w"> </span><span class="n">固定池中线程数量</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">适合1</span><span class="p">.</span><span class="na">执行较长任务</span><span class="err">；</span><span class="n">2</span><span class="p">.</span><span class="na">控制并发度</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">CachedThreadPool</span><span class="err">：</span><span class="n">池中线程数量不固定</span><span class="err">，</span><span class="n">根据需要动态创建线程</span><span class="err">，</span><span class="n">空的被回收</span><span class="err">，</span><span class="n">少了多创建</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">⭐</span><span class="n">适用于任务执行时间短且任务数量不确定的场景</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ScheduledThreadPool</span><span class="err">：</span><span class="n">适用于需要定时执行或周期性执行任务的场景</span><span class="err">。</span><span class="w">    
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 定时任务线程池</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ScheduledExecutorService</span><span class="w"> </span><span class="n">scheduledThreadPool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executors</span><span class="p">.</span><span class="na">newScheduledThreadPool</span><span class="p">(</span><span class="n">5</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// For 延迟任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">scheduledThreadPool</span><span class="p">.</span><span class="na">schedule</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 任务逻辑</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">},</span><span class="w"> </span><span class="n">10</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">);</span><span class="w"> </span><span class="c1">// 延迟10秒执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// For周期执行任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">scheduledThreadPool</span><span class="p">.</span><span class="na">scheduleAtFixedRate</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 任务逻辑</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">},</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">);</span><span class="w"> </span><span class="c1">// 每隔1秒执行一次</span><span class="w">
</span></span></span></code></pre></div><p>Thread.sleep(0) &lt;= 主动让出CPU控制权</p>
<p>thread.join() &lt;= 等待该线程完成</p>
<h3 id="2-创建线程池">2 创建线程池<a hidden class="anchor" aria-hidden="true" href="#2-创建线程池">#</a></h3>
<p>1） Executors<strong>工厂类</strong></p>
<ul>
<li>Executors.newFixedThreadPool(10) //</li>
</ul>
<p>2）ThreadPoolExecutor直接创建<strong>线程池</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">corePoolSize</span><span class="p">,</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">,</span><span class="w"> </span><span class="n">KeepAliveTime</span><span class="p">,</span><span class="n">TimeUnit</span><span class="p">,</span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">LinkedBlockingQueue</span><span class="p">:</span><span class="w"> </span><span class="n">当提交的任务多于线程数时</span><span class="err">，</span><span class="n">会将多余的暂时挂起</span><span class="w">
</span></span></span></code></pre></div><p><strong>线程池相关参数解释</strong></p>
<ul>
<li>corePoolSize：核心线程数，即线程池中始终保存的线程数量；</li>
<li>maximumPoolSize：最大线程数，线程池中允许的最大线程数量；</li>
<li>KeepAliveTime：线程空闲时间，非核心线程空闲超过这个时间会被销毁；</li>
<li>workQueue：工作队列，存放待执行的任务；</li>
<li>threadFactory：线程工厂，用于创建新线程；</li>
<li>rejectedExecutionHandler：任务拒绝处理器，当前任务无法执行时的处理策略。</li>
</ul>
<p><strong>工作队列</strong></p>
<ul>
<li>SynchronousQueue：不存储任务，直接提交任务给线程；</li>
<li>LinkedBlockingQueue：链表结构的阻塞队列，大小无限；</li>
<li>ArrayBlockingQueue：数据结构的阻塞队列；</li>
<li>PriorityBlockingQueue：带优先级的无界阻塞队列。/ praɪˈɒrəti /</li>
</ul>
<p><strong>线程池的拒绝策略</strong></p>
<p>队列满且无空闲线程的添加任务的情况。</p>
<ul>
<li>AbortPolicy：抛异常；</li>
<li>CallerRunsPolicy：由提交线程本身执行；</li>
<li>DiscardOldestPolicy：删除最早提交的任务；</li>
<li>DiscardPolicy：直接丢弃当前任务。</li>
</ul>
<h3 id="3-线程安全的集合">3 线程安全的集合<a hidden class="anchor" aria-hidden="true" href="#3-线程安全的集合">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nl">concurrentHashMap</span><span class="p">:</span><span class="w"> </span><span class="n">同步HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">-&gt;</span><span class="n">V</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">数据结构</span><span class="o">=&gt;</span><span class="w"> </span><span class="n">使用数组</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">链表</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">红黑树的结构</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">线程安全</span><span class="o">=&gt;</span><span class="w"> </span><span class="n">CAS保证操作的原子性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">eg</span><span class="p">:</span><span class="n">线程不安全的操作</span><span class="err">：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 非线程安全的操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 这里，如果有其他线程对key-&gt;value进行了修改！，这里的value是过期了的</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// ⭐保证原子性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">map</span><span class="p">.</span><span class="na">compute</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 一次完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 如果是方法中创建的Map,每个线程专享，不会有线程间安全问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 如果是类中，且多个线程共享同一个Class实例，则可能出现线程安全问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Method中创建</span><span class="err">：</span><span class="n">安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Class</span><span class="o">-</span><span class="n">成员变量</span><span class="err">：</span><span class="n">多个线程可能共享同一个map实例</span><span class="err">，</span><span class="n">需要保证线程安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Class</span><span class="o">-</span><span class="n">静态变量</span><span class="err">：</span><span class="n">所有线程共享同一个</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">实例</span><span class="w"> </span><span class="err">，</span><span class="n">需要保证线程安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">BlockingQueue</span><span class="err">：</span><span class="w"> </span><span class="o">-</span><span class="n">数组实现</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">LinkedBlockingQueue</span><span class="p">:</span><span class="w"> </span><span class="n">线程安全的阻塞队列</span><span class="o">-</span><span class="n">链表实现</span><span class="w">
</span></span></span></code></pre></div><h3 id="4-线程同步">4 线程同步<a hidden class="anchor" aria-hidden="true" href="#4-线程同步">#</a></h3>
<p>多线程情况下，避免共享资源同时访问，引发数据不一致。=&gt; 加锁，限制访问。</p>
<p>JAVA中，常见的同步方式：</p>
<p><strong>synchronized</strong> 同步 // 仅限一个线程访问.  由 JVM 负责管理锁的获取和释放. 非公平锁</p>
<p>生产-消费 模拟</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Main</span><span class="err">：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 共享队列，用于生产者和消费者之间的数据传递</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// or BlockingQueue</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">maxSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// 队列的最大容量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 创建生产者和消费者线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Thread</span><span class="w"> </span><span class="n">producer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Producer</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">maxSize</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;Producer&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Thread</span><span class="w"> </span><span class="n">consumer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Consumer</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;Consumer&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 启动线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">producer</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">consumer</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">    
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nl">Producer</span><span class="p">:</span><span class="w"> </span><span class="n">实现Runnable</span><span class="w"> </span><span class="kd">interface</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="nc">Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 对队列加锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 如果队列已满，生产者等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">maxSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;队列已满，生产者等待...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">queue</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// 释放锁，进入等待状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 生产数据并添加到队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;生产者生产数据: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">queue</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 通知消费者可以消费了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">queue</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 模拟生产耗时</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">500</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Consumer</span><span class="err">：</span><span class="n">实现Runnable接口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 对队列加锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 如果队列为空，消费者等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;队列为空，消费者等待...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">queue</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// 释放锁，进入等待状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 消费数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;消费者消费数据: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 通知生产者可以生产了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">queue</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 模拟消费耗时</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>⭐⭐⭐</p>
<p>synchronized（临界区对象）  &lt;=  锁住临界区</p>
<p>while(临界区不可用) =&gt; 重试 =&gt; .wait() 当前线程进入等待状态<strong>让出CPU</strong>，并且<strong>释放锁</strong></p>
<p>处理完成=&gt; .notifyAll() // 通知等待状态的线程</p>
<p><strong><code>synchronized</code></strong>：通过 <code>Object.wait()</code> 和 <code>Object.notify()/notifyAll()</code> 进行线程间通信</p>
<hr>
<p><strong>ReentrantLock</strong>  可重入锁  Re en trant lock.  需要手动加锁和释放锁</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 临界区代码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong><code>ReentrantLock</code></strong>：使用 <code>Condition</code> 对象更灵活地控制线程等待和唤醒：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Condition</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="na">newCondition</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">condition</span><span class="p">.</span><span class="na">await</span><span class="p">();</span><span class="w">  </span><span class="c1">// 线程等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">condition</span><span class="p">.</span><span class="na">signal</span><span class="p">();</span><span class="w"> </span><span class="c1">// 唤醒单个等待的线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">condition</span><span class="p">.</span><span class="na">signalAll</span><span class="p">();</span><span class="w"> </span><span class="c1">// 唤醒所有等待的线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>案例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 共享队列，用于生产者和消费者之间的数据传递</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 创建 ReentrantLock 和 Condition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Lock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Condition</span><span class="w"> </span><span class="n">notFull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="na">newCondition</span><span class="p">();</span><span class="w"> </span><span class="c1">// 队列未满的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Condition</span><span class="w"> </span><span class="n">notEmpty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="na">newCondition</span><span class="p">();</span><span class="w"> </span><span class="c1">// 队列非空的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">Producer</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="na">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">maxSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;队列已满，生产者等待...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">notFull</span><span class="p">.</span><span class="na">await</span><span class="p">();</span><span class="w"> </span><span class="c1">// 等待队列未满的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">queue</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="o">?</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">notEmpty</span><span class="p">.</span><span class="na">signalAll</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// ... 生产耗时</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="k">finally</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">Consumer</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="na">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">sout</span><span class="p">(</span><span class="s">&#34;没东西消费&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">notEmpty</span><span class="p">.</span><span class="na">await</span><span class="p">()</span><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">queue</span><span class="p">.</span><span class="na">poll</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">notFull</span><span class="p">.</span><span class="na">signalAll</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// ...消费时长</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="k">finally</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>⭐⭐⭐ 关键用法：</p>
<p>Lock lock = new ReentrantLock();
Condition notFull = lock.newCondition(); // 队列未满的条件
Condition notEmpty = lock.newCondition(); // 队列非空的条件</p>
<p>lock.lock &amp;&amp; lock.unlock</p>
<p>notFull.await(),  notFull.signal(),  notFull.signalAll()</p>
<hr>
<h3 id="5-线程安全">5 线程安全<a hidden class="anchor" aria-hidden="true" href="#5-线程安全">#</a></h3>
<p>保证多线程，乱序执行时候，无论怎么执行，都可以得到预期结果</p>
<p>=&gt; <strong>通过 线程同步</strong> (悲观锁)</p>
<p>通过Synchronized 和 ReentrantLock   ˈsɪŋkrənaɪzd &amp;  riːˈentrənt, lɒk 实现线程同步</p>
<p>=&gt; <strong>通过原子操作类</strong></p>
<p>AtomicInteger  əˈtɒmɪk 原子，  原子整数</p>
<p>⭐⭐⭐<em><strong>扩展CAS</strong></em>（乐观锁）：（<strong>Compare And Swap</strong>，比较并交换）是一种无锁并发编程技术，常用于实现<strong>原子操作</strong>。它的基本原理是：<strong>先比较，再交换</strong>，即<strong>只有当变量的当前值等于预期值时，才会更新，否则重试</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 当前值, 预期值, 新值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">boolean</span><span class="w"> </span><span class="nf">compareAndSwap</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">V</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">E</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 比较当前值是否等于预期值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w">    </span><span class="c1">// 如果相等，更新为新值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 操作成功</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 操作失败</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>例子：最佳实践案例=&gt; 线程安全的计数器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 线程安全的递增方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">oldValue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">newValue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">oldValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w"> </span><span class="c1">// 获取当前值, 先获取修改值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">newValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oldValue</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 计算新值 </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">value</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="n">newValue</span><span class="p">));</span><span class="w"> </span><span class="c1">// CAS 操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// CAS  compare and swap &lt;=&gt; 访问到修改期间，没有其他线程进行修改的话，就可以执行 </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">value</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">oldValue</span><span class="p">,</span><span class="w"> </span><span class="n">newValue</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">oldvalue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="na">get</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newValue</span><span class="w"> </span><span class="err">：</span><span class="n">nothing</span><span class="w">
</span></span></span></code></pre></div><p><strong>检查第一次得到的旧值与修改时的值是否一致，判断是否被动过，没动过再改</strong></p>
<p><img alt="image-20250303211427792" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250303211427792.png"></p>
<p>=&gt; <strong>线程安全的容器</strong>：concurrentHashMap or copyonWriteArrayList❌ <strong>不懂</strong></p>
<p>=&gt; <strong>局部变量</strong>，线程专享</p>
<p>=&gt; <strong>ThreadLocal</strong>, 线程本地资源，线程专享</p>
<h3 id="6-线程生命周期">6 线程生命周期<a hidden class="anchor" aria-hidden="true" href="#6-线程生命周期">#</a></h3>
<p>初始(资源) =&gt; 可运行(CPU队列) =&gt; 运行 =&gt; 终止</p>
<p>​                                     阻塞&amp;等待</p>
<h3 id="7-线程通信">7 线程通信<a hidden class="anchor" aria-hidden="true" href="#7-线程通信">#</a></h3>
<p>多线程间的协同工作</p>
<p>1）**共享变量：**访问共享内存变量来交换信息；</p>
<p>2）<strong>同步机制：</strong></p>
<p>synchronized() =&gt; wait =&gt; notify&amp;notifyAll  （Object中的方法）</p>
<p>ReentrantLock.lock =&gt; condition.await =&gt; condition.signal&amp;signalAll</p>
<p>BlockingQueue =&gt; queue.put() 满则阻塞 =&gt; queue.take() 空则阻塞</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">conditionNotMet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">lock</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// 释放锁，进入等待状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="c1">// 执行操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">lock</span><span class="p">.</span><span class="na">notify</span><span class="p">();</span><span class="w"> </span><span class="c1">// 唤醒等待的线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Lock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Condition</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="na">newCondition</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">conditionNotMet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">condition</span><span class="p">.</span><span class="na">await</span><span class="p">();</span><span class="w"> </span><span class="c1">// 等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="c1">// 执行操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">condition</span><span class="p">.</span><span class="na">signal</span><span class="p">();</span><span class="w"> </span><span class="c1">// 唤醒等待的线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 生产者</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">queue</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;Data&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 消费者</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">String</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue</span><span class="p">.</span><span class="na">take</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><h3 id="8-线程池">8 线程池<a hidden class="anchor" aria-hidden="true" href="#8-线程池">#</a></h3>
<p>池化技术，预先创建并管理一组线程，避免线程重复创建和销毁带来的开销</p>
<p>关键配置：核心线程数，最大线程数，空间存活时间，工作队列，拒绝策略</p>
<p>=&gt; 提交任务才会创建线程，或者设置preStartAllCoreThreads</p>
<p>=&gt; 核心线程满了不会创建线程，而是把多余的任务放到工作队列中，等待执行</p>
<p>=&gt; 核心线程满载且工作队列放不下了，才会新增线程执行提交的任务(&lt;最大线程数)</p>
<p>=&gt; 工作队列满了+已最大线程数了 =&gt; 拒绝策略?新任务</p>
<p>=&gt; 线程空闲时间超过指定时间 且有多余的非核心线程 =&gt; 释放非核心线程</p>
<p>工作队列：</p>
<p>LinkedBlockingQueue 无界队列，链式</p>
<p>ArrayBlockingQueue 有界队列，数组</p>
<p>PriorityBlockingQueue 带有优先级的无界阻塞队列</p>
<p>线程池类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nl">FixedThreadPool</span><span class="p">:</span><span class="w"> </span><span class="n">固定线程数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">CachedThreadPool</span><span class="err">：</span><span class="n">变化</span><span class="err">，</span><span class="n">动态新建</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">SingleThreadPool</span><span class="err">：</span><span class="n">单线程的池子</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ScheduledThreadPool</span><span class="err">：</span><span class="n">定时任务的池子</span><span class="w">
</span></span></span></code></pre></div><p>shutdown与shutdownNow的区别</p>
<p>shutdown：提醒关闭，会把已提交的任务执行完毕</p>
<p>shutdownNow：强制停止</p>
<h3 id="9-并发工具类">9 并发工具类<a hidden class="anchor" aria-hidden="true" href="#9-并发工具类">#</a></h3>
<ul>
<li>
<p>ConcurrentHashMap：线程安全的HashMap，多线程修改临界区时加锁或者其他方法，=&gt;安全</p>
</li>
<li>
<p>AtomicInterger：əˈtɒmɪk   线程安全的整型  compareAndSet CAS方法，原子类型</p>
</li>
<li>
<p>Semaphore 信号量：acquire() and release()</p>
</li>
<li>
<p>BlockingQueue：阻塞队列-通信容器  queue.put() and queue.take()</p>
</li>
<li>
<p>CyclicBarrier：循环屏障 barrier.await</p>
</li>
<li>
<p>CountDownlatch：计时器 latch.countDown() latch.await()</p>
</li>
</ul>
<h3 id="497-reentrantlock实现">497 ReentrantLock实现<a hidden class="anchor" aria-hidden="true" href="#497-reentrantlock实现">#</a></h3>
<p>=&gt; 可重入锁，允许同一个线程多次获取同一把锁的锁机制，避免线程因为重复获取锁而导致死锁</p>
<p>案例：1. 递归调用中的锁保护</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="err">#</span><span class="w"> </span><span class="n">非公平锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">final</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">nonfairTryAcquire</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">acquires</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getState</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 锁未被占用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetState</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">acquires</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// CAS 尝试获取锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">setExclusiveOwnerThread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span><span class="w"> </span><span class="c1">// 设置当前线程为独占线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getExclusiveOwnerThread</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ⭐⭐⭐锁已被当前线程占用（重入）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">nextc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acquires</span><span class="p">;</span><span class="w"> </span><span class="c1">// 增加重入次数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nextc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">setState</span><span class="p">(</span><span class="n">nextc</span><span class="p">);</span><span class="w"> </span><span class="c1">// 更新状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 获取锁失败</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>基于AQS实现的一个可重入锁</strong>，支持公平和非公平两种方式</p>
<p>内部依靠一个<strong>State变量</strong>和两个等待<strong>队列</strong>：同步队列和等待队列</p>
<p>利用CAS修改state来争夺锁</p>
<ul>
<li>
<p>争抢不到锁就入<strong>AQS 等待队列</strong>进行等待，<strong>AQS 等待队列</strong>是一个双向队列</p>
</li>
<li>
<p>抢到锁但是条件condition不满足则入<strong>条件队列(每个condition维护一个)</strong>，单向链表</p>
</li>
</ul>
<p>是否公平锁 =&gt; 线程获取锁 是加入同步队列尾部还是直接利用CAS争夺锁</p>
<p><img alt="image-20250305195628416" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250305195628416.png"></p>
<p><code>ReentrantLock</code> 是基于 AQS 实现的可重入独占锁，支持公平锁和非公平锁两种模式。其核心是通过 AQS 的状态管理（<code>state</code>）和等待队列来实现线程的阻塞和唤醒。非公平锁的性能通常优于公平锁，但<strong>公平锁可以避免线程饥饿</strong>问题。<code>ReentrantLock</code> 提供了比 <code>synchronized</code> 更灵活的锁操作，是 Java 并发编程中的重要工具</p>
<h3 id="492-synchronized实现">492 Synchronized实现<a hidden class="anchor" aria-hidden="true" href="#492-synchronized实现">#</a></h3>
<p>依赖于JVM的监视器锁+对象头</p>
<p>当synchronized修饰在方法或者代码块上时，会对特定的对象或者类加锁，确保只有一个线程能运行加锁的代码块；</p>
<ul>
<li>synchronized修饰方法：方法的<strong>标志</strong>位会增加一个ACC_SYNCHRONIZED标志，检查标志再获取锁，这部分进行同步控制</li>
<li>synchronized修饰代码块：会在代码块前后插入monitorenter和monitorexit字节码指令，上锁+解锁</li>
</ul>
<p>synchronized是可重入锁</p>
<h3 id="491-synchronized和reentrantlock">491 Synchronized和ReentrantLock<a hidden class="anchor" aria-hidden="true" href="#491-synchronized和reentrantlock">#</a></h3>
<p><img alt="image-20250305205348468" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250305205348468.png"></p>
<h3 id="496-如何优化java中锁的使用">496 如何优化Java中锁的使用？<a hidden class="anchor" aria-hidden="true" href="#496-如何优化java中锁的使用">#</a></h3>
<ol>
<li><strong>减少锁的粒度</strong>：
<ol>
<li>减少加锁的范围，减少锁的持续时间</li>
</ol>
</li>
<li>使用<strong>更细粒度的锁</strong>：提高并发度
<ul>
<li>hashTable:
<ul>
<li>通过方法上添加synchronized实现锁的安全，仅一个线程，性能较差</li>
</ul>
</li>
<li>concurrentHashMap：
<ul>
<li>通过CAS+synchronized实现线程安全，允许多个线程同时读写，性能更高</li>
</ul>
</li>
</ul>
</li>
<li>减少锁的使用
<ol>
<li>通过无锁编程、CAS操作和原子类来避免锁的使用，减少锁带来的性能损失</li>
<li>通过减少共享资源的使用，避免对临界区的竞争。(本地变量+线程本地变量)</li>
</ol>
</li>
</ol>
<p>扩展：</p>
<ul>
<li>独占锁：写操作多的场景，仅允许一个线程持有锁</li>
<li>读写锁：允许多个线程并发读，但写的时候需要上锁，适合读多写少的场景</li>
<li>乐观锁和悲观锁：悲观锁每次都加锁；乐观锁假设没有冲突-CAS或版本号实现</li>
</ul>
<h3 id="499-读写锁">499 读写锁<a hidden class="anchor" aria-hidden="true" href="#499-读写锁">#</a></h3>
<p>允许多个线程同时读操作，但是写操作需要加锁(单个线程)。</p>
<p>=&gt; 读写+写写操纵是互斥操作；⭐适合读多写少的情况</p>
<p>可以利用ReadWriteLock和ReentrantReadWriteLock实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="err">#</span><span class="w"> </span><span class="n">代码示例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ReentrantReadWriteLock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantReadWriteLock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Lock</span><span class="w"> </span><span class="n">readLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="na">readLock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">lock</span><span class="w"> </span><span class="n">writeLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span><span class="na">writeLock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 1. 判断写锁(读写互斥)2. 判断读锁,第一个和后续</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">readLock</span><span class="p">.</span><span class="na">lock</span><span class="p">()</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">readLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 1. 有读锁或写锁且写锁不是当前线程持有，则失败</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 2. 根据公平性策略（公平锁或非公平锁）决定是否需要阻塞</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 3. CAS 更新状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 4. 设置写锁持有者 &lt;= 设置可重入</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">writeLock</span><span class="p">.</span><span class="na">lock</span><span class="p">()</span><span class="w"> </span><span class="c1">// 互斥 写写互斥</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">writeLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="501-java-jmm-java内存模型">501 Java JMM java内存模型<a hidden class="anchor" aria-hidden="true" href="#501-java-jmm-java内存模型">#</a></h3>
<p>java memory model</p>
<p>用于描述线程何时从主内存中读取数据、何时把数据写回主存中</p>
<p>JMM核心目标</p>
<ul>
<li><strong>可见性</strong>：确保某个线程的修改，其他线程及时可见。 使用volatile关键字强制线程每次读写都直接从主内存中获取新值</li>
<li><strong>有序性</strong>：指线程执行操作的顺序，JMM允许某些指令通过指令重拍提高性能，且保证线程内的操作顺序不会被破坏，通过<code>happens-before</code>关系保证跨线程的有序性。</li>
<li>**原子性：**指操作不可分割，线程不会在执行过程中被中断。</li>
</ul>
<p>Why JMM：</p>
<p>操作系统有自己的内存模型，但JAVA是跨平台实现的，因此需要自己设计一套内存模型屏蔽各操作系统之间的差异。JMM描述了多线程环境下，如何在不通过的线程之间共享变量以及变量的操作顺序。</p>
<p>主内存和工作内存：</p>
<ul>
<li>主内存：JAVA堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存中；</li>
<li>工作内存：每个线程都有自己的工作内存，工作内存存储了主内存中的变量副本，线程的所有操作都在工作内存中进行。</li>
<li>线程之间的变量，必须经过主内存进行传递</li>
</ul>
<h3 id="506-why-threadlocal">506 Why ThreadLocal<a hidden class="anchor" aria-hidden="true" href="#506-why-threadlocal">#</a></h3>
<p>每个线程自己<strong>独享的独立变量副本</strong>，避免多个线程间的变量共享和竞争，解决线程安全问题。</p>
<p><strong>每个</strong>线程维护一个<code>ThreadLocalMap</code> 用于存储线程独立的变量副本，ThreadLocalMap以ThreadLocal实例为键，不同线程通过自己ThreadLocal身份获取各自的变量副本。</p>
<p>避免同一个ThreadLocalMap的竞争</p>
<h3 id="517-java中waitnotify和notifyall">517 Java中wait、notify和notifyALL<a hidden class="anchor" aria-hidden="true" href="#517-java中waitnotify和notifyall">#</a></h3>
<p>这三个方法都是Object对象定义的方法，用于线程之间的通信，且需要在Synchronized修饰内使用</p>
<ul>
<li>wait =&gt; 线程进入等待状态，释放锁</li>
<li>notify =&gt; 唤醒一个在等待的线程</li>
<li>notifyALL =&gt; 唤醒所有等待的线程</li>
</ul>
<h3 id="518-死锁-及-避免">518 死锁 及 避免<a hidden class="anchor" aria-hidden="true" href="#518-死锁-及-避免">#</a></h3>
<ul>
<li>条件互斥：独享资源</li>
<li>占有且等待：不放手，等别人放弃</li>
<li>不可抢占：文明</li>
<li>循环等待： A=&gt;B=&gt;C=&gt;A</li>
</ul>
<p>避免：</p>
<ul>
<li>按序申请 =&gt; 锁获取的顺序相同，这样就可以在前面卡住</li>
<li>超时等待时间=&gt;释放手中资源和锁</li>
</ul>
<h3 id="519-volatile关键字">519 volatile关键字<a hidden class="anchor" aria-hidden="true" href="#519-volatile关键字">#</a></h3>
<p>主要的作用还是保证变量的可见性</p>
<ul>
<li>可见性：修改了volatile变量的值，该值会被立刻刷新回主内存中，及时让其他线程可见。</li>
</ul>
<h3 id="6304-如何知晓子线程是否执行完毕">6304 如何知晓子线程是否执行完毕？<a hidden class="anchor" aria-hidden="true" href="#6304-如何知晓子线程是否执行完毕">#</a></h3>
<ul>
<li>ThreadObj.join() 会等待对应子线程执行完毕</li>
<li>FutureTask+Callable   futrue.get() 拿到线程执行完成的结果</li>
<li>回调机制：完成后，调用回调函数通知主线程，异步了</li>
</ul>
<h3 id="481-semaphore-信号量">481 Semaphore 信号量<a hidden class="anchor" aria-hidden="true" href="#481-semaphore-信号量">#</a></h3>
<p>ˈseməfɔːr</p>
<p>主要作用就是确保 只有指定数量的线程能够访问资源，<strong>限制同时访问特定资源的线程数量</strong></p>
<p><em>基本概念</em></p>
<ul>
<li>
<p>许可 permits: 可以访问资源的线程数量。</p>
</li>
<li>
<p>Acquire：尝试获取许可；</p>
</li>
<li>
<p>release：释放许可。</p>
</li>
<li>
<p>公平：按照请求顺序获取许可，防止线程饥饿</p>
</li>
<li>
<p>非公平：可以提高性能。</p>
</li>
</ul>
<p>常见用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Semaphore</span><span class="w"> </span><span class="n">semaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Semaphore</span><span class="p">(</span><span class="n">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// 允许最多10个线程访问</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">semaphore</span><span class="p">.</span><span class="na">acquire</span><span class="p">();</span><span class="w"> </span><span class="c1">// 失败会阻塞不会往下执行了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 访问共享资源</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">semaphore</span><span class="p">.</span><span class="na">release</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Semaphore</span><span class="w"> </span><span class="n">semaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Semaphore</span><span class="p">(</span><span class="n">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// 允许最多5个线程同时执行任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">semaphore</span><span class="p">.</span><span class="na">acquire</span><span class="p">();</span><span class="w"> </span><span class="c1">// 阻塞</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 执行任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">semaphore</span><span class="p">.</span><span class="na">release</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="482-cyclicbarrier">482 CyclicBarrier<a hidden class="anchor" aria-hidden="true" href="#482-cyclicbarrier">#</a></h3>
<p>ˈsaɪklɪk ˈbæriə(r) 循环障碍 // <strong>可以重用</strong>，当所有线程到达屏障后，刷新</p>
<p>允许一组线程在执行某个任务相互等待，直到所有线程都达到了Barrier屏障后才能继续执行 // 直接全卡住</p>
<ul>
<li>屏障：调用barrier.await() 阻塞，等待所有线程都到达屏障；</li>
<li>线程数量：预指定的，当所有线程到达屏障，所有线程才被唤醒；</li>
<li>重用性：可以被重用。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="err">#</span><span class="w"> </span><span class="n">示例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">static</span><span class="w"> </span><span class="n">CyclicBarrier</span><span class="w"> </span><span class="n">cyclicbarrier</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cyclicbarrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CyclicBarrier</span><span class="p">(</span><span class="n">parties</span><span class="o">=</span><span class="n">10</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Sout</span><span class="p">(</span><span class="s">&#34;全部准备就绪&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="p">...)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">3000</span><span class="w"> </span><span class="n">ms</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sout</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="s">&#34;玩家准备完成&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cyclicbarrier</span><span class="p">.</span><span class="na">await</span><span class="p">()</span><span class="w"> </span><span class="c1">// ⭐等待全部完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sout</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="s">&#34;玩家进入游戏&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">})</span><span class="w">  
</span></span></span></code></pre></div><h3 id="483-countdownlatch">483 CountDownLatch<a hidden class="anchor" aria-hidden="true" href="#483-countdownlatch">#</a></h3>
<p>倒计时门闩锁  - 不可复用</p>
<p>作用：<strong>使某线程等待其他线程执行完一组操作完成</strong>。每当其他线程完成一个操作，计数器&ndash;，到达0则等待的ALL线程会被唤醒</p>
<p>主要功能：</p>
<ul>
<li>等待事件完成：await()；</li>
<li>递减计数器：latch.countdown()；</li>
<li>线程同步：当计数器变为0，唤醒线程。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">CountDownLatch</span><span class="w"> </span><span class="n">latch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CountDownLatch</span><span class="p">(</span><span class="n">3</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 异步</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">,</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">3000</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sout</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="s">&#34;???&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">latch</span><span class="p">.</span><span class="na">countDown</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这里模拟递减计数器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}).</span><span class="na">start</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">sout</span><span class="p">(</span><span class="s">&#34;wait all thread finish&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">latch</span><span class="p">.</span><span class="na">await</span><span class="p">()</span><span class="w"> </span><span class="c1">// 主线程阻塞等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">sout</span><span class="p">(</span><span class="s">&#34;all thread finish&#34;</span><span class="p">)</span><span class="w">    
</span></span></span></code></pre></div><p>// 并行计算结果的汇总</p>
<h3 id="487-如何控制多个线程的执行顺序呢">487 如何控制多个线程的执行顺序呢？<a hidden class="anchor" aria-hidden="true" href="#487-如何控制多个线程的执行顺序呢">#</a></h3>
<ul>
<li>synchronized + awit + notify, A =&gt; B =&gt; C 多组锁</li>
<li>ReentrantLock + condition 多组</li>
<li>Thread.join, 逐步等待</li>
<li>CountDownLatch，等待其他的线程countdown</li>
<li>semaphore，限制异步为同步顺序</li>
</ul>
<h3 id="488-java阻塞队列">488 Java阻塞队列<a hidden class="anchor" aria-hidden="true" href="#488-java阻塞队列">#</a></h3>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorBlockingQueue praɪə(r)</li>
</ul>
<h3 id="489-原子类">489 原子类<a hidden class="anchor" aria-hidden="true" href="#489-原子类">#</a></h3>
<ul>
<li>AtomicInterger                           əˈtɒmɪk ˈɪntɪdʒə(r)</li>
<li>AtomicStampedReference            stæmpt</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="p">.</span><span class="na">get</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">compareAndSet</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">getAndIncrement</span><span class="w">    </span><span class="n">ˈɪŋkrəmənt</span><span class="w">
</span></span></span></code></pre></div><h3 id="提问">提问<a hidden class="anchor" aria-hidden="true" href="#提问">#</a></h3>
<h4 id="cas">CAS<a hidden class="anchor" aria-hidden="true" href="#cas">#</a></h4>
<p>Compare and swap</p>
<p>比较内存中的值 是否与 之前的预期值(之前拿到的旧值) 相等</p>
<p>相等 =&gt; 将该变量的值设置为新值</p>
<p>=&gt; 判断从之前的访问到现在的修改，中间变量的值是否变动过，没变过=&gt;可以修改</p>
<p>优势：</p>
<p><strong>无锁并发</strong> + CAS是原子性的(线程安全)</p>
<p>缺点：</p>
<ul>
<li>ABA问题，如果变量值 从 A=&gt;B=&gt;A,CAS无法检测到这种变化</li>
<li><strong>自旋(重复)开销</strong>：导致CPU资源浪费，因为一直比较，直到能够修改为止</li>
<li>单变量限制：仅支持修改单变量</li>
</ul>
<p>ABA问题：引入版本号或者时间戳，每次更新变量的同时更新版本号，从而依靠版本号判断变量是否被调整过。</p>
<p>做法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">atomicStampedReference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// 初始值:版本号 == 0:0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">updateValue</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">newValue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">stampHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Integer</span><span class="w"> </span><span class="n">currentValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicStampedReference</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">stampHolder</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">currentStamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stampHolder</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicStampedReference</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">newValue</span><span class="p">,</span><span class="w"> </span><span class="n">currentStamp</span><span class="p">,</span><span class="w"> </span><span class="n">currentStamp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">updated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Value updated to &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">newValue</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Update failed&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>AtomicStampedReference：&lt;ObjRef =&gt; stampedref&gt;</p>
<p><strong>尝试更新值和版本号</strong></p>
<p>boolean updated = atomicStampedReference.compareAndSet(expected, newValue, currentStamp, currentStamp + 1);</p>
<p>期望的当前值，更新值，期望的版本号，更新的版本号; <strong>当期望的两个值相同才更新</strong></p>
<p>辅助理解</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">newValue</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ready</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 获取当前引用值和版本号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">stampHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 因为Java只能返回一个返回值，将多个结果修改数组的形式间接返回</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Integer</span><span class="w"> </span><span class="n">currentValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicStampedRef</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">stampHolder</span><span class="p">);</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">currentStamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stampHolder</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⭐⭐⭐</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="s">&#34;当前值: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">currentValue</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">版本号</span><span class="p">:</span><span class="w"> </span><span class="s">&#34; + currentStamp 
</span></span></span><span class="line"><span class="cl"><span class="s">    
</span></span></span><span class="line"><span class="cl"><span class="s">atomicStampedReference.compareAndSet(expected, newValue, currentStamp, currentStamp + 1);
</span></span></span></code></pre></div><p>在CAS基础上，多判断一个版本号，检查变量是否修改过，解决ABA问题</p>
<p>// ##</p>
<p>自旋锁 =&gt; 获取锁失败，不会阻塞，而是重复尝试获取锁 ❗非公平:饥饿；性能问题:对同一变量高并发进行CAS</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SpinLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">AtomicBoolean</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicBoolean</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">lock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 自旋等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unlock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>针对自旋锁=&gt;CLH</p>
<h4 id="aqs">AQS<a hidden class="anchor" aria-hidden="true" href="#aqs">#</a></h4>
<p><strong>Abstract Queued Synchronizer</strong> 是同步器的基础框架， 起到抽象、封装的作用，将一些排队、入队、加锁、中断方法提供出来，具体加锁时机、入队时机等需要实现类自己控制。</p>
<ul>
<li><strong>(volatile申明)state状态</strong>，可以通过CAS无锁并发方式竞争锁</li>
</ul>
<p>AQS支持</p>
<ol>
<li>独占模式：只有一个线程可以执行，互斥锁；</li>
<li>共享模式：多个线程可以同时执行，例如信号量；</li>
</ol>
<p>当一个线程获取锁失败时，AQS将其插入等待队列中，并阻塞线程，直到同步状态可用。</p>
<p>使用AQS实现一个独占锁</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SimpleLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Sync</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">AbstractQueuedSynchronizer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">tryAcquire</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">acquires</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetState</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">setExclusiveOwnerThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">tryRelease</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">releases</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">getState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalMonitorStateException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">setExclusiveOwnerThread</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">setState</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isHeldExclusively</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">getState</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">ConditionObject</span><span class="w"> </span><span class="nf">newCondition</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConditionObject</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Sync</span><span class="w"> </span><span class="n">sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Sync</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">lock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sync</span><span class="p">.</span><span class="na">acquire</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unlock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sync</span><span class="p">.</span><span class="na">release</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isLocked</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sync</span><span class="p">.</span><span class="na">isHeldExclusively</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Condition</span><span class="w"> </span><span class="nf">newCondition</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sync</span><span class="p">.</span><span class="na">newCondition</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="err">#</span><span class="w"> </span><span class="n">基于AQS的独占锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">tryAcquire</span><span class="p">:</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">CAS</span><span class="p">(</span><span class="n">原子</span><span class="err">，</span><span class="n">比较且设置</span><span class="p">)</span><span class="n">检查是否锁可以使用</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">可以则设置当前线程为独占模式</span><span class="w"> </span><span class="kc">true</span><span class="o">=&gt;</span><span class="k">else</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">tryRelease</span><span class="p">:</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">如果不为1则异常</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">关闭独占模式并释放锁</span><span class="p">(</span><span class="n">state设置为0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Sync</span><span class="w"> </span><span class="n">sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Sync</span><span class="p">()</span><span class="w"> </span><span class="c1">// 作为锁对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">lock</span><span class="p">:</span><span class="w"> </span><span class="n">sync</span><span class="p">.</span><span class="na">acquire</span><span class="p">(</span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">unlock</span><span class="p">:</span><span class="w"> </span><span class="n">sync</span><span class="p">.</span><span class="na">release</span><span class="p">(</span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>AQS和CAS两者可以经常一起使用，例如在ReentrantLock中，CAS用于实现锁的获取和释放操作，而AQS则管理锁的状态和等待队列。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/jobs/java/">
    <span class="title">« 上一页</span>
    <br>
    <span></span>
  </a>
  <a class="next" href="http://localhost:1313/posts/jobs/jvm/">
    <span class="title">下一页 »</span>
    <br>
    <span></span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">LongWei Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
