<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LongCoding&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="请作为面试官的角度，回答。场景 &#43; 方法 or 问题 &#43; 措施

学习要点

编写的Java文件是怎么运行的？

JVM - 类加载


JVM的内存是如何管理的呢？分配和回收？

JVM 内存结构
JMM相关
JVM内存分配
JVM垃圾回收


如何结合实际的机器调整JVM参数，最佳实践呢？

JVM基础 - 类字节码详解
Java代码是运行在JVM上的，而JVM能够屏蔽掉不同具体的设备差异，这提供了很好的移植性。
.Java文件 需要编译为 .class文件字节码文件才能被JVM运行。其中.class文件就是以字节为单位，将类数据按照顺序紧凑的排列在class文件中(有格式模板)。JVM按照预设的模板解析。
Class文件的结构：


字节码(Class)文件信息


常量池: 存储字面量、字段的名称和描述符号、方法的名称和描述符等&hellip;

字面量类似于java中的常量概念，如文本字符串，final常量等;



方法表集合：对类内部的方法描述(类型，权限修饰)。包括成员变量和方法的描述；

code内的主要属性：

stack：最大操作数栈，根据这个分配栈帧
locals: 局部变量所需的存储空间
args_size: 方法参数的个数，每个实例方法都会有一个隐藏参数this
attribute_info: 方法体内容
LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。
LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系





 1Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class
 2  Last modified 2018-4-7; size 362 bytes
 3  MD5 checksum 4aed8540b098992663b7ba08c65312de
 4  Compiled from &#34;Main.java&#34;
 5public class com.rhythm7.Main
 6  minor version: 0
 7  major version: 52
 8  flags: ACC_PUBLIC, ACC_SUPER
 9
10Constant pool:
11   #1 = Methodref          #4.#18         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
12   #2 = Fieldref           #3.#19         // com/rhythm7/Main.m:I
13   #3 = Class              #20            // com/rhythm7/Main
14   #4 = Class              #21            // java/lang/Object
15   #5 = Utf8               m
16   #6 = Utf8               I
17   #7 = Utf8               &lt;init&gt;
18   #8 = Utf8               ()V
19   #9 = Utf8               Code
20  #10 = Utf8               LineNumberTable
21  #11 = Utf8               LocalVariableTable
22  #12 = Utf8               this
23  #13 = Utf8               Lcom/rhythm7/Main;
24  #14 = Utf8               inc
25  #15 = Utf8               ()I
26  #16 = Utf8               SourceFile
27  #17 = Utf8               Main.java
28  #18 = NameAndType        #7:#8          // &#34;&lt;init&gt;&#34;:()V
29  #19 = NameAndType        #5:#6          // m:I
30  #20 = Utf8               com/rhythm7/Main
31  #21 = Utf8               java/lang/Object
32
33{
34  private int m;
35    descriptor: I
36    flags: ACC_PRIVATE
37
38  public com.rhythm7.Main();
39    descriptor: ()V
40    flags: ACC_PUBLIC
41    Code:
42      stack=1, locals=1, args_size=1
43         0: aload_0
44         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
45         4: return
46      LineNumberTable:
47        line 3: 0
48      LocalVariableTable:
49        Start  Length  Slot  Name   Signature
50            0       5     0  this   Lcom/rhythm7/Main;
51
52  public int inc();
53    descriptor: ()I
54    flags: ACC_PUBLIC
55    Code:
56      stack=2, locals=1, args_size=1
57         0: aload_0
58         1: getfield      #2                  // Field m:I
59         4: iconst_1
60         5: iadd
61         6: ireturn
62      LineNumberTable:
63        line 8: 0
64      LocalVariableTable:
65        Start  Length  Slot  Name   Signature
66            0       7     0  this   Lcom/rhythm7/Main;
67}
68SourceFile: &#34;Main.java&#34;
JVM基础 - 类的加载过程
类加载过程包括：加载，验证，准备， 解析， 初始化 这几个阶段；">
<meta name="author" content="👨🏻‍🎓 LongWei">
<link rel="canonical" href="http://longcoding.top/posts/jobs/jvm%E7%9B%B8%E5%85%B3-pdai/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://longcoding.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://longcoding.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://longcoding.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://longcoding.top/apple-touch-icon.png">
<link rel="mask-icon" href="http://longcoding.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://longcoding.top/posts/jobs/jvm%E7%9B%B8%E5%85%B3-pdai/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://longcoding.top/posts/jobs/jvm%E7%9B%B8%E5%85%B3-pdai/">
  <meta property="og:site_name" content="LongCoding&#39;s Blog">
  <meta property="og:title" content="LongCoding&#39;s Blog">
  <meta property="og:description" content="请作为面试官的角度，回答。场景 &#43; 方法 or 问题 &#43; 措施
学习要点
编写的Java文件是怎么运行的？ JVM - 类加载 JVM的内存是如何管理的呢？分配和回收？ JVM 内存结构 JMM相关 JVM内存分配 JVM垃圾回收 如何结合实际的机器调整JVM参数，最佳实践呢？ JVM基础 - 类字节码详解 Java代码是运行在JVM上的，而JVM能够屏蔽掉不同具体的设备差异，这提供了很好的移植性。
.Java文件 需要编译为 .class文件字节码文件才能被JVM运行。其中.class文件就是以字节为单位，将类数据按照顺序紧凑的排列在class文件中(有格式模板)。JVM按照预设的模板解析。
Class文件的结构：
字节码(Class)文件信息
常量池: 存储字面量、字段的名称和描述符号、方法的名称和描述符等…
字面量类似于java中的常量概念，如文本字符串，final常量等; 方法表集合：对类内部的方法描述(类型，权限修饰)。包括成员变量和方法的描述；
code内的主要属性： stack：最大操作数栈，根据这个分配栈帧 locals: 局部变量所需的存储空间 args_size: 方法参数的个数，每个实例方法都会有一个隐藏参数this attribute_info: 方法体内容 LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。 LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系 1Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class 2 Last modified 2018-4-7; size 362 bytes 3 MD5 checksum 4aed8540b098992663b7ba08c65312de 4 Compiled from &#34;Main.java&#34; 5public class com.rhythm7.Main 6 minor version: 0 7 major version: 52 8 flags: ACC_PUBLIC, ACC_SUPER 9 10Constant pool: 11 #1 = Methodref #4.#18 // java/lang/Object.&#34;&lt;init&gt;&#34;:()V 12 #2 = Fieldref #3.#19 // com/rhythm7/Main.m:I 13 #3 = Class #20 // com/rhythm7/Main 14 #4 = Class #21 // java/lang/Object 15 #5 = Utf8 m 16 #6 = Utf8 I 17 #7 = Utf8 &lt;init&gt; 18 #8 = Utf8 ()V 19 #9 = Utf8 Code 20 #10 = Utf8 LineNumberTable 21 #11 = Utf8 LocalVariableTable 22 #12 = Utf8 this 23 #13 = Utf8 Lcom/rhythm7/Main; 24 #14 = Utf8 inc 25 #15 = Utf8 ()I 26 #16 = Utf8 SourceFile 27 #17 = Utf8 Main.java 28 #18 = NameAndType #7:#8 // &#34;&lt;init&gt;&#34;:()V 29 #19 = NameAndType #5:#6 // m:I 30 #20 = Utf8 com/rhythm7/Main 31 #21 = Utf8 java/lang/Object 32 33{ 34 private int m; 35 descriptor: I 36 flags: ACC_PRIVATE 37 38 public com.rhythm7.Main(); 39 descriptor: ()V 40 flags: ACC_PUBLIC 41 Code: 42 stack=1, locals=1, args_size=1 43 0: aload_0 44 1: invokespecial #1 // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V 45 4: return 46 LineNumberTable: 47 line 3: 0 48 LocalVariableTable: 49 Start Length Slot Name Signature 50 0 5 0 this Lcom/rhythm7/Main; 51 52 public int inc(); 53 descriptor: ()I 54 flags: ACC_PUBLIC 55 Code: 56 stack=2, locals=1, args_size=1 57 0: aload_0 58 1: getfield #2 // Field m:I 59 4: iconst_1 60 5: iadd 61 6: ireturn 62 LineNumberTable: 63 line 8: 0 64 LocalVariableTable: 65 Start Length Slot Name Signature 66 0 7 0 this Lcom/rhythm7/Main; 67} 68SourceFile: &#34;Main.java&#34; JVM基础 - 类的加载过程 类加载过程包括：加载，验证，准备， 解析， 初始化 这几个阶段；">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
      <meta property="og:image" content="http://longcoding.top/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://longcoding.top/papermod-cover.png">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="请作为面试官的角度，回答。场景 &#43; 方法 or 问题 &#43; 措施

学习要点

编写的Java文件是怎么运行的？

JVM - 类加载


JVM的内存是如何管理的呢？分配和回收？

JVM 内存结构
JMM相关
JVM内存分配
JVM垃圾回收


如何结合实际的机器调整JVM参数，最佳实践呢？

JVM基础 - 类字节码详解
Java代码是运行在JVM上的，而JVM能够屏蔽掉不同具体的设备差异，这提供了很好的移植性。
.Java文件 需要编译为 .class文件字节码文件才能被JVM运行。其中.class文件就是以字节为单位，将类数据按照顺序紧凑的排列在class文件中(有格式模板)。JVM按照预设的模板解析。
Class文件的结构：


字节码(Class)文件信息


常量池: 存储字面量、字段的名称和描述符号、方法的名称和描述符等&hellip;

字面量类似于java中的常量概念，如文本字符串，final常量等;



方法表集合：对类内部的方法描述(类型，权限修饰)。包括成员变量和方法的描述；

code内的主要属性：

stack：最大操作数栈，根据这个分配栈帧
locals: 局部变量所需的存储空间
args_size: 方法参数的个数，每个实例方法都会有一个隐藏参数this
attribute_info: 方法体内容
LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。
LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系





 1Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class
 2  Last modified 2018-4-7; size 362 bytes
 3  MD5 checksum 4aed8540b098992663b7ba08c65312de
 4  Compiled from &#34;Main.java&#34;
 5public class com.rhythm7.Main
 6  minor version: 0
 7  major version: 52
 8  flags: ACC_PUBLIC, ACC_SUPER
 9
10Constant pool:
11   #1 = Methodref          #4.#18         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
12   #2 = Fieldref           #3.#19         // com/rhythm7/Main.m:I
13   #3 = Class              #20            // com/rhythm7/Main
14   #4 = Class              #21            // java/lang/Object
15   #5 = Utf8               m
16   #6 = Utf8               I
17   #7 = Utf8               &lt;init&gt;
18   #8 = Utf8               ()V
19   #9 = Utf8               Code
20  #10 = Utf8               LineNumberTable
21  #11 = Utf8               LocalVariableTable
22  #12 = Utf8               this
23  #13 = Utf8               Lcom/rhythm7/Main;
24  #14 = Utf8               inc
25  #15 = Utf8               ()I
26  #16 = Utf8               SourceFile
27  #17 = Utf8               Main.java
28  #18 = NameAndType        #7:#8          // &#34;&lt;init&gt;&#34;:()V
29  #19 = NameAndType        #5:#6          // m:I
30  #20 = Utf8               com/rhythm7/Main
31  #21 = Utf8               java/lang/Object
32
33{
34  private int m;
35    descriptor: I
36    flags: ACC_PRIVATE
37
38  public com.rhythm7.Main();
39    descriptor: ()V
40    flags: ACC_PUBLIC
41    Code:
42      stack=1, locals=1, args_size=1
43         0: aload_0
44         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
45         4: return
46      LineNumberTable:
47        line 3: 0
48      LocalVariableTable:
49        Start  Length  Slot  Name   Signature
50            0       5     0  this   Lcom/rhythm7/Main;
51
52  public int inc();
53    descriptor: ()I
54    flags: ACC_PUBLIC
55    Code:
56      stack=2, locals=1, args_size=1
57         0: aload_0
58         1: getfield      #2                  // Field m:I
59         4: iconst_1
60         5: iadd
61         6: ireturn
62      LineNumberTable:
63        line 8: 0
64      LocalVariableTable:
65        Start  Length  Slot  Name   Signature
66            0       7     0  this   Lcom/rhythm7/Main;
67}
68SourceFile: &#34;Main.java&#34;
JVM基础 - 类的加载过程
类加载过程包括：加载，验证，准备， 解析， 初始化 这几个阶段；">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://longcoding.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "http://longcoding.top/posts/jobs/jvm%E7%9B%B8%E5%85%B3-pdai/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "请作为面试官的角度，回答。场景 + 方法 or 问题 + 措施\n学习要点\n编写的Java文件是怎么运行的？ JVM - 类加载 JVM的内存是如何管理的呢？分配和回收？ JVM 内存结构 JMM相关 JVM内存分配 JVM垃圾回收 如何结合实际的机器调整JVM参数，最佳实践呢？ JVM基础 - 类字节码详解 Java代码是运行在JVM上的，而JVM能够屏蔽掉不同具体的设备差异，这提供了很好的移植性。\n.Java文件 需要编译为 .class文件字节码文件才能被JVM运行。其中.class文件就是以字节为单位，将类数据按照顺序紧凑的排列在class文件中(有格式模板)。JVM按照预设的模板解析。\nClass文件的结构：\n字节码(Class)文件信息\n常量池: 存储字面量、字段的名称和描述符号、方法的名称和描述符等\u0026hellip;\n字面量类似于java中的常量概念，如文本字符串，final常量等; 方法表集合：对类内部的方法描述(类型，权限修饰)。包括成员变量和方法的描述；\ncode内的主要属性： stack：最大操作数栈，根据这个分配栈帧 locals: 局部变量所需的存储空间 args_size: 方法参数的个数，每个实例方法都会有一个隐藏参数this attribute_info: 方法体内容 LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。 LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系 1Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class 2 Last modified 2018-4-7; size 362 bytes 3 MD5 checksum 4aed8540b098992663b7ba08c65312de 4 Compiled from \u0026#34;Main.java\u0026#34; 5public class com.rhythm7.Main 6 minor version: 0 7 major version: 52 8 flags: ACC_PUBLIC, ACC_SUPER 9 10Constant pool: 11 #1 = Methodref #4.#18 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 12 #2 = Fieldref #3.#19 // com/rhythm7/Main.m:I 13 #3 = Class #20 // com/rhythm7/Main 14 #4 = Class #21 // java/lang/Object 15 #5 = Utf8 m 16 #6 = Utf8 I 17 #7 = Utf8 \u0026lt;init\u0026gt; 18 #8 = Utf8 ()V 19 #9 = Utf8 Code 20 #10 = Utf8 LineNumberTable 21 #11 = Utf8 LocalVariableTable 22 #12 = Utf8 this 23 #13 = Utf8 Lcom/rhythm7/Main; 24 #14 = Utf8 inc 25 #15 = Utf8 ()I 26 #16 = Utf8 SourceFile 27 #17 = Utf8 Main.java 28 #18 = NameAndType #7:#8 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 29 #19 = NameAndType #5:#6 // m:I 30 #20 = Utf8 com/rhythm7/Main 31 #21 = Utf8 java/lang/Object 32 33{ 34 private int m; 35 descriptor: I 36 flags: ACC_PRIVATE 37 38 public com.rhythm7.Main(); 39 descriptor: ()V 40 flags: ACC_PUBLIC 41 Code: 42 stack=1, locals=1, args_size=1 43 0: aload_0 44 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 45 4: return 46 LineNumberTable: 47 line 3: 0 48 LocalVariableTable: 49 Start Length Slot Name Signature 50 0 5 0 this Lcom/rhythm7/Main; 51 52 public int inc(); 53 descriptor: ()I 54 flags: ACC_PUBLIC 55 Code: 56 stack=2, locals=1, args_size=1 57 0: aload_0 58 1: getfield #2 // Field m:I 59 4: iconst_1 60 5: iadd 61 6: ireturn 62 LineNumberTable: 63 line 8: 0 64 LocalVariableTable: 65 Start Length Slot Name Signature 66 0 7 0 this Lcom/rhythm7/Main; 67} 68SourceFile: \u0026#34;Main.java\u0026#34; JVM基础 - 类的加载过程 类加载过程包括：加载，验证，准备， 解析， 初始化 这几个阶段；\n",
  "keywords": [
    
  ],
  "articleBody": "请作为面试官的角度，回答。场景 + 方法 or 问题 + 措施\n学习要点\n编写的Java文件是怎么运行的？ JVM - 类加载 JVM的内存是如何管理的呢？分配和回收？ JVM 内存结构 JMM相关 JVM内存分配 JVM垃圾回收 如何结合实际的机器调整JVM参数，最佳实践呢？ JVM基础 - 类字节码详解 Java代码是运行在JVM上的，而JVM能够屏蔽掉不同具体的设备差异，这提供了很好的移植性。\n.Java文件 需要编译为 .class文件字节码文件才能被JVM运行。其中.class文件就是以字节为单位，将类数据按照顺序紧凑的排列在class文件中(有格式模板)。JVM按照预设的模板解析。\nClass文件的结构：\n字节码(Class)文件信息\n常量池: 存储字面量、字段的名称和描述符号、方法的名称和描述符等…\n字面量类似于java中的常量概念，如文本字符串，final常量等; 方法表集合：对类内部的方法描述(类型，权限修饰)。包括成员变量和方法的描述；\ncode内的主要属性： stack：最大操作数栈，根据这个分配栈帧 locals: 局部变量所需的存储空间 args_size: 方法参数的个数，每个实例方法都会有一个隐藏参数this attribute_info: 方法体内容 LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。 LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系 1Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class 2 Last modified 2018-4-7; size 362 bytes 3 MD5 checksum 4aed8540b098992663b7ba08c65312de 4 Compiled from \"Main.java\" 5public class com.rhythm7.Main 6 minor version: 0 7 major version: 52 8 flags: ACC_PUBLIC, ACC_SUPER 9 10Constant pool: 11 #1 = Methodref #4.#18 // java/lang/Object.\"\":()V 12 #2 = Fieldref #3.#19 // com/rhythm7/Main.m:I 13 #3 = Class #20 // com/rhythm7/Main 14 #4 = Class #21 // java/lang/Object 15 #5 = Utf8 m 16 #6 = Utf8 I 17 #7 = Utf8 \u003cinit\u003e 18 #8 = Utf8 ()V 19 #9 = Utf8 Code 20 #10 = Utf8 LineNumberTable 21 #11 = Utf8 LocalVariableTable 22 #12 = Utf8 this 23 #13 = Utf8 Lcom/rhythm7/Main; 24 #14 = Utf8 inc 25 #15 = Utf8 ()I 26 #16 = Utf8 SourceFile 27 #17 = Utf8 Main.java 28 #18 = NameAndType #7:#8 // \"\":()V 29 #19 = NameAndType #5:#6 // m:I 30 #20 = Utf8 com/rhythm7/Main 31 #21 = Utf8 java/lang/Object 32 33{ 34 private int m; 35 descriptor: I 36 flags: ACC_PRIVATE 37 38 public com.rhythm7.Main(); 39 descriptor: ()V 40 flags: ACC_PUBLIC 41 Code: 42 stack=1, locals=1, args_size=1 43 0: aload_0 44 1: invokespecial #1 // Method java/lang/Object.\"\":()V 45 4: return 46 LineNumberTable: 47 line 3: 0 48 LocalVariableTable: 49 Start Length Slot Name Signature 50 0 5 0 this Lcom/rhythm7/Main; 51 52 public int inc(); 53 descriptor: ()I 54 flags: ACC_PUBLIC 55 Code: 56 stack=2, locals=1, args_size=1 57 0: aload_0 58 1: getfield #2 // Field m:I 59 4: iconst_1 60 5: iadd 61 6: ireturn 62 LineNumberTable: 63 line 8: 0 64 LocalVariableTable: 65 Start Length Slot Name Signature 66 0 7 0 this Lcom/rhythm7/Main; 67} 68SourceFile: \"Main.java\" JVM基础 - 类的加载过程 类加载过程包括：加载，验证，准备， 解析， 初始化 这几个阶段；\n加载：根据类的全限定名将Class文件加载到方法区，并转化为运行时的数据结构；并且在堆中生成一个Class对象，作为方法区数据的访问入口 1Class\u003c?\u003e clazz = Class.forName(\"com.example.Demo\"); 2Method method = clazz.getMethod(\"test\"); // 通过Class对象访问方法区的方法信息 连接 验证 - 保证被加载的类的正确性，校验字节码文件信息 准备 - 为类的静态变量分配内存，并初始化默认值（分配在方法区中） 解析 - 把类中的符合引用转换为直接引用。 初始化：为类的静态变量赋予正确的初始值 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 类加载器：\nBootstrap ClassLoader：启动类加载器，负责加载存放在JDK\\jre\\lib下，或者被虚拟机识别的类库。JDK java.*开头的类\nExtension ClassLoader：扩展类加载器，负责加载JDK\\jre\\lib\\ext目录中的所有库，javax.*开头的类\nApplication ClassLoader：负责加载用户类路径(ClassPath)所指定的类；\nUserImpl ClassLoader\n双亲委派机制, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n优势：\n系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 JVM基础 - JVM内存结构 Java虚拟机(JVM)内存结构是指JVM在执行Java程序时所管理的内存区域划分，这些内存区域各有不同的用途和生命周期。\n❗注意：和JMM不是一个东西！\n线程私有：程序计数器、虚拟机栈、本地方法区 线程共享：堆、方法区、堆外内存 一、程序计数器 作用：记录 JVM 字节码下一条执行的指令地址。\n扩展：因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\n二、虚拟机栈 作用：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。每个方法都各自有对应的一个栈帧。\n栈帧 - 方法调用和执行的基本单位\n局部变量表：方法内定义的局部变量 操作数栈：用于方法执行时的计算，存储临时数据（如算术运算、方法参数传递） 可理解为草稿纸，函数中执行的计算，不可能一步完成，可能需要多步记录，这个栈可以用来暂存信息或函数调用时传参数。 动态链接：存储指向运行时常量池（Runtime Constant Pool）的引用，用于方法调用时的符号解析 【符合引用修改为内存中的入口地址-直接引用】 存储方法在运行时常量池中的引用，用于支持多态方法调用（如接口方法、重写方法）；运行时才链接实际调用的方法(支持多态)； 方法返回地址：存储方法执行完毕后返回的位置（调用者的程序计数器 PC 值） 附加信息。 三、堆内存 作用： 存放对象的实例。被所有线程共享。\n高效回收： 将堆内存逻辑上分为三块 （优化GC的性能）\n新生代：新对象和没到一定年龄的对象都放在新生代； 老年代：被长时间使用的对象； 元空间： 具体：\n新生代：\n伊甸园区(Eden Memory) + 两个幸存区(Survivor Memory), 默认比例是 8:1:1 大多数对象创建的时候都放置在Eden内存空间中；(首次) 当Eden区被填充满，会执行Minor GC，将幸存的对象移动到一个幸存区中； 两个两个幸存区使用的是复制算法； 经过多轮Minor GC仍存活的对象会复制到 Eden区。默认是15次，因为这个标识使用4个比特； 老年代\n存放多次Minor GC仍存活的对象。当老年代内存满了，会执行Major GC 大的对象，占据大量连续内存的对象会直接放入到老年代中，避免在两个幸存区中进行大量的内存拷贝； 设置JVM堆内存大小\n-Xms来设置堆的起始内存 -Xmx来设置堆的最大内存 对象在堆中的生命周期\n在 JVM 内存模型的堆中，堆被划分为新生代和老年代 新生代又被进一步划分为 Eden区 和 Survivor区，Survivor 区由 From Survivor 和 To Survivor 组成 当创建一个对象时，对象会被优先分配到新生代的 Eden 区 此时 JVM 会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold） 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1 如果分配的对象超过了-XX:PetenureSizeThreshold，对象会**直接被分配到老年代 四、方法区 目的：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码\n类信息的仓库：存储加载的类的元数据（字段、方法、常量池等） 常量池：字面量(“abc”,123, final常量) 和 符号引用(类和接口的全限定名+字段和方法名称和描述符) 运行时常量池：类加载时，将常量池转变为运行时常量池。主要就是修改符号引用，调整为直接引用(内存实际地址)，运行时动态添加常量(String.intern()) 静态变量的家：存放 static 变量和编译期常量。 JIT 的缓存：存储热点代码的本地机器码。 动态性的基石：支持反射、动态代理等高级特性 五、本地方法栈 **目的：**用于支持 Native 方法（本地方法） 的执行。非Java语言的方法，例如操作系统提供的方法；原理与虚拟机栈类似\n❌JVM基础 - JMM (Java 内存模型) 现在的电脑：CPU - Cache - 内存三级架构，并且CPU是多核的。这样的话，线程之间可能是同时运行的。\n会导致两个问题\n两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。(CPU将结果存储在Cache中，并没有及时的写回内存) volatile 确保线程修改共享变量后对其他线程立即可见 两个线程将共享对象的变量计数读入其CPU缓存中，例如初始为1，每个线程自增1，同步的情况下应该为3，但是未合理同步导致为2. 使用Java synchronized块, 保证同一时间只有一个线程可以进入临界资源。 JMM基础\n定义：定义了线程如何与内存交互，以及线程之间如何通过内存进行通信。\n核心概念：\n主内存和工作内存 主内存：共享变量 工作内存：线程私有的内存区域，存放局部变量和共享变量副本 内存间交互操作 从主内存读取共享变量的线程工作内存 线程将工作内存的共享变量写回主内存 happens-before原则 (重排序) 编译器和处理器常常会对指令做重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。提高执行效率 这些重排序都可能会导致多线程程序出现内存可见性问题 插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序 JMM带来的问题\n可见性 volatile关键字，读取和修改都及时从内存中进行读写，保证修改的结果对其他线程及时可见 有序性 synchronized、concurrent包提供的，原子类和锁机制实现。 原子性 synchronized关键字进行加锁，通过互斥实现线程安全； GC 垃圾回收 **目的：**释放掉不使用了的内存空间，主要针对的是堆和方法区\n判断一个对象是否可以被回收 引用计数 给对象添加一个引用计数器，每被引用一次则+1。当值为0表示没有被其他对象引用，可以回收 缺点：会产生循环引用的情况，就是对象A引用对象B，对象B引用对象A，但是这俩对象都不再使用，但是无法回收，导致内存泄漏。 可达性分析 通过 GC root作为起始点进行搜索，能够到达的对象都是存活对象，不可达的对象会被回收。 GC root对象一般包括： 虚拟机栈、本地方法栈、方法区静态属性、方法区常量引用中引用的对象 类的卸载条件：(需要满足以下三点，且满足了也不一定回收)\n所有实例被回收 对应的类加载器被回收 类的Class对象被回收，那么在任何地方都无法通过Class对象反射访问该类方法 引用类型 强引用: 被强关联的对象 1Object obj = new Object(); 软引用：只有内存空间不足时才会被回收；使用场景：外部资源，比如图片缓存等… 可以再次获取。 1Object obj = new Object(); 2SoftReference\u003cObject\u003e sf = new SoftReference\u003cObject\u003e(obj); 3obj = null; // 使对象只被软引用关联 弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用场景：临时缓存 1Object obj = new Object(); 2WeakReference\u003cObject\u003e wf = new WeakReference\u003cObject\u003e(obj); 3obj = null; 虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 1Object obj = new Object(); 2PhantomReference\u003cObject\u003e pf = new PhantomReference\u003cObject\u003e(obj); 3obj = null; 垃圾回收算法 标记 - 清除 标记存活的对象，清理掉未被标记的对象 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 标记 - 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 分代回收 一般将堆分为新生代和老年代。 新生代使用: 标记 - 复制算法 老年代使用: 标记 - 整理 算法 垃圾收集器 设计目标：吞吐量 or 延迟\nSerial new + old 收集器 ˈsɪəriəl 串行进行垃圾回收。单CPU环境下性能高，因为没有上下文切换的开销。会存在stop the world 死区。 年轻代-标记复制；老年代-标记整理 Parallel Scavenge + Parallel Old收集器 ˈpærəlel ˈskævɪndʒ Serial的多线程版 年轻代-标记复制(多线程)；老年代-标记整理(多线程) ParNew：\nCMS： Concurrent Mark Sweep swiːp\nParNew - CMS 收集器 为了配合CMS产生的ParNew 年轻代-多线程复制；老年代-并发标记-清除(CMS) CMS收集器： 降低延迟 初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快（只扫第一层引用），需要停顿。 STW暂停 并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。(****递归标记所有存活对象（从初始标记的对象出发，遍历整个对象图）) 让GC和用户线程交替工作，减少停顿时间 重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。(修正并发标记期间的引用变化) STW暂停 (卡表标记变更的区域) 并发清除: 不需要停顿。 G1 收集器 新生代：分区复制 + 标记-整理 老年代：分区标记-整理 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。\n每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。\n如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:\n初始标记： 并发标记 最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点:\n空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 内存分配和回收策略 Minor GC、Major GC、 Full GC\nMinor GC: 收集新生代垃圾\nMajor GC： 收集老年代垃圾\nMixed GC：G1收集器，收集新生代垃圾和部分老年代垃圾\nFull GC：收集整个堆和方法区垃圾\n内存分配策略\n对象优先在Eden区分配 当Eden区内存不足，发起minor GC 大对象直接进老年代 避免在Eden区和survivor区之间的大量内存复制 长期存活对象进老年代 默认minor gc 15次之后 动态年龄判断：当Survivor 中相同年龄所有对象大小总和超过一般的Survivor区，将大于等于该年龄的对象移动到老年代中； Full GC触发条件\n调用System.gc()：手动调用，只是建议并不一定执行。不推荐 老年代空间不足 ",
  "wordCount" : "772",
  "inLanguage": "en",
  "image": "http://longcoding.top/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "👨🏻‍🎓 LongWei"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://longcoding.top/posts/jobs/jvm%E7%9B%B8%E5%85%B3-pdai/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LongCoding's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://longcoding.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://longcoding.top/" accesskey="h" title="𝓛𝓸𝓷𝓰𝓒𝓸𝓭𝓲𝓷𝓰 (Alt + H)">
                <img src="http://longcoding.top/android-icon-48x48.png" alt="" aria-label="logo"
                    height="30">𝓛𝓸𝓷𝓰𝓒𝓸𝓭𝓲𝓷𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://longcoding.top/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/archives/" title="📃 Archives">
                    <span>📃 Archives</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/categories/" title="🗒️ Categories">
                    <span>🗒️ Categories</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/about/" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://longcoding.top/">Home</a>&nbsp;»&nbsp;<a href="http://longcoding.top/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">4 min&nbsp;·&nbsp;772 words&nbsp;·&nbsp;👨🏻‍🎓 LongWei

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#jvm%e5%9f%ba%e7%a1%80---%e7%b1%bb%e5%ad%97%e8%8a%82%e7%a0%81%e8%af%a6%e8%a7%a3" aria-label="JVM基础 - 类字节码详解">JVM基础 - 类字节码详解</a></li>
                <li>
                    <a href="#jvm%e5%9f%ba%e7%a1%80---%e7%b1%bb%e7%9a%84%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b" aria-label="JVM基础 - 类的加载过程">JVM基础 - 类的加载过程</a></li>
                <li>
                    <a href="#jvm%e5%9f%ba%e7%a1%80---jvm%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84" aria-label="JVM基础 - JVM内存结构">JVM基础 - JVM内存结构</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8" aria-label="一、程序计数器">一、程序计数器</a></li>
                <li>
                    <a href="#%e4%ba%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88" aria-label="二、虚拟机栈">二、虚拟机栈</a></li>
                <li>
                    <a href="#%e4%b8%89%e5%a0%86%e5%86%85%e5%ad%98" aria-label="三、堆内存">三、堆内存</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%96%b9%e6%b3%95%e5%8c%ba" aria-label="四、方法区">四、方法区</a></li>
                <li>
                    <a href="#%e4%ba%94%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88" aria-label="五、本地方法栈">五、本地方法栈</a></li></ul>
                </li>
                <li>
                    <a href="#jvm%e5%9f%ba%e7%a1%80---jmm-java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" aria-label="❌JVM基础 - JMM (Java 内存模型)">❌JVM基础 - JMM (Java 内存模型)</a></li>
                <li>
                    <a href="#gc-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" aria-label="GC 垃圾回收">GC 垃圾回收</a><ul>
                        
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e8%a2%ab%e5%9b%9e%e6%94%b6" aria-label="判断一个对象是否可以被回收">判断一个对象是否可以被回收</a></li>
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b" aria-label="引用类型">引用类型</a></li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95" aria-label="垃圾回收算法">垃圾回收算法</a></li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8" aria-label="垃圾收集器">垃圾收集器</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%9e%e6%94%b6%e7%ad%96%e7%95%a5" aria-label="内存分配和回收策略">内存分配和回收策略</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>请作为面试官的角度，回答。场景 + 方法 or 问题 + 措施</p>
<p><img alt="image-20250428184345824" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428184345824.png"></p>
<p><strong>学习要点</strong></p>
<ul>
<li>编写的Java文件是怎么运行的？
<ul>
<li>JVM - 类加载</li>
</ul>
</li>
<li>JVM的内存是如何管理的呢？分配和回收？
<ul>
<li>JVM 内存结构</li>
<li>JMM相关</li>
<li>JVM内存分配</li>
<li>JVM垃圾回收</li>
</ul>
</li>
<li>如何结合实际的机器调整JVM参数，最佳实践呢？</li>
</ul>
<h3 id="jvm基础---类字节码详解">JVM基础 - 类字节码详解<a hidden class="anchor" aria-hidden="true" href="#jvm基础---类字节码详解">#</a></h3>
<p>Java代码是运行在JVM上的，而JVM能够屏蔽掉不同具体的设备差异，这提供了很好的<strong>移植性</strong>。</p>
<p><code>.Java文件</code> 需要编译为 <code>.class文件</code>字节码文件才能被JVM运行。其中<code>.class文件</code>就是以字节为单位，将类数据按照顺序紧凑的排列在class文件中(有格式模板)。JVM按照预设的模板解析。</p>
<p><strong>Class文件的结构</strong>：</p>
<ul>
<li>
<p>字节码(Class)文件信息</p>
</li>
<li>
<p>常量池: 存储字面量、字段的名称和描述符号、方法的名称和描述符等&hellip;</p>
<ul>
<li>字面量类似于java中的常量概念，如文本字符串，final常量等;</li>
</ul>
</li>
<li>
<p>方法表集合：对类内部的方法描述(类型，权限修饰)。包括成员变量和方法的描述；</p>
<ul>
<li>code内的主要属性：
<ul>
<li><strong>stack</strong>：最大操作数栈，根据这个分配栈帧</li>
<li><strong>locals</strong>: 局部变量所需的存储空间</li>
<li><strong>args_size</strong>: 方法参数的个数，每个实例方法都会有一个隐藏参数this</li>
<li><strong>attribute_info</strong>: 方法体内容</li>
<li><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。</li>
<li><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Classfile</span><span class="w"> </span><span class="o">/</span><span class="n">E</span><span class="p">:</span><span class="o">/</span><span class="n">JavaCode</span><span class="o">/</span><span class="n">TestProj</span><span class="o">/</span><span class="n">out</span><span class="o">/</span><span class="n">production</span><span class="o">/</span><span class="n">TestProj</span><span class="o">/</span><span class="n">com</span><span class="o">/</span><span class="n">rhythm7</span><span class="o">/</span><span class="n">Main</span><span class="p">.</span><span class="na">class</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">  </span><span class="n">Last</span><span class="w"> </span><span class="n">modified</span><span class="w"> </span><span class="n">2018</span><span class="o">-</span><span class="n">4</span><span class="o">-</span><span class="n">7</span><span class="p">;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">362</span><span class="w"> </span><span class="n">bytes</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">  </span><span class="n">MD5</span><span class="w"> </span><span class="n">checksum</span><span class="w"> </span><span class="n">4aed8540b098992663b7ba08c65312de</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">  </span><span class="n">Compiled</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="s">&#34;Main.java&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">com</span><span class="p">.</span><span class="na">rhythm7</span><span class="p">.</span><span class="na">Main</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="n">minor</span><span class="w"> </span><span class="n">version</span><span class="p">:</span><span class="w"> </span><span class="n">0</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">  </span><span class="n">major</span><span class="w"> </span><span class="n">version</span><span class="p">:</span><span class="w"> </span><span class="n">52</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">  </span><span class="n">flags</span><span class="p">:</span><span class="w"> </span><span class="n">ACC_PUBLIC</span><span class="p">,</span><span class="w"> </span><span class="n">ACC_SUPER</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w"></span><span class="n">Constant</span><span class="w"> </span><span class="n">pool</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Methodref</span><span class="w">          </span><span class="err">#</span><span class="n">4</span><span class="p">.</span><span class="err">#</span><span class="n">18</span><span class="w">         </span><span class="c1">// java/lang/Object.&#34;&lt;init&gt;&#34;:()V</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fieldref</span><span class="w">           </span><span class="err">#</span><span class="n">3</span><span class="p">.</span><span class="err">#</span><span class="n">19</span><span class="w">         </span><span class="c1">// com/rhythm7/Main.m:I</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Class</span><span class="w">              </span><span class="err">#</span><span class="n">20</span><span class="w">            </span><span class="c1">// com/rhythm7/Main</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Class</span><span class="w">              </span><span class="err">#</span><span class="n">21</span><span class="w">            </span><span class="c1">// java/lang/Object</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">m</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">I</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="o">&lt;</span><span class="n">init</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="p">()</span><span class="n">V</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">   </span><span class="err">#</span><span class="n">9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">Code</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">LineNumberTable</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">LocalVariableTable</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="k">this</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">Lcom</span><span class="o">/</span><span class="n">rhythm7</span><span class="o">/</span><span class="n">Main</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">14</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">inc</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">15</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="p">()</span><span class="n">I</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">SourceFile</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">17</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">Main</span><span class="p">.</span><span class="na">java</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">18</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NameAndType</span><span class="w">        </span><span class="err">#</span><span class="n">7</span><span class="p">:</span><span class="err">#</span><span class="n">8</span><span class="w">          </span><span class="c1">// &#34;&lt;init&gt;&#34;:()V</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">19</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NameAndType</span><span class="w">        </span><span class="err">#</span><span class="n">5</span><span class="p">:</span><span class="err">#</span><span class="n">6</span><span class="w">          </span><span class="c1">// m:I</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">20</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">com</span><span class="o">/</span><span class="n">rhythm7</span><span class="o">/</span><span class="n">Main</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">  </span><span class="err">#</span><span class="n">21</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Utf8</span><span class="w">               </span><span class="n">java</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">    </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="n">I</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">    </span><span class="n">flags</span><span class="p">:</span><span class="w"> </span><span class="n">ACC_PRIVATE</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">com</span><span class="p">.</span><span class="na">rhythm7</span><span class="p">.</span><span class="na">Main</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">    </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="n">V</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">    </span><span class="n">flags</span><span class="p">:</span><span class="w"> </span><span class="n">ACC_PUBLIC</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">    </span><span class="n">Code</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w">      </span><span class="n">stack</span><span class="o">=</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="o">=</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">args_size</span><span class="o">=</span><span class="n">1</span><span class="w">
</span></span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="w">         </span><span class="n">0</span><span class="p">:</span><span class="w"> </span><span class="n">aload_0</span><span class="w">
</span></span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="w">         </span><span class="n">1</span><span class="p">:</span><span class="w"> </span><span class="n">invokespecial</span><span class="w"> </span><span class="err">#</span><span class="n">1</span><span class="w">                  </span><span class="c1">// Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V</span><span class="w">
</span></span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="w">         </span><span class="n">4</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w">
</span></span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="w">      </span><span class="n">LineNumberTable</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">47</span><span class="cl"><span class="w">        </span><span class="n">line</span><span class="w"> </span><span class="n">3</span><span class="p">:</span><span class="w"> </span><span class="n">0</span><span class="w">
</span></span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="w">      </span><span class="n">LocalVariableTable</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">49</span><span class="cl"><span class="w">        </span><span class="n">Start</span><span class="w">  </span><span class="n">Length</span><span class="w">  </span><span class="n">Slot</span><span class="w">  </span><span class="n">Name</span><span class="w">   </span><span class="n">Signature</span><span class="w">
</span></span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="w">            </span><span class="n">0</span><span class="w">       </span><span class="n">5</span><span class="w">     </span><span class="n">0</span><span class="w">  </span><span class="k">this</span><span class="w">   </span><span class="n">Lcom</span><span class="o">/</span><span class="n">rhythm7</span><span class="o">/</span><span class="n">Main</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">51</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">52</span><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">inc</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">53</span><span class="cl"><span class="w">    </span><span class="n">descriptor</span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="n">I</span><span class="w">
</span></span></span><span class="line"><span class="ln">54</span><span class="cl"><span class="w">    </span><span class="n">flags</span><span class="p">:</span><span class="w"> </span><span class="n">ACC_PUBLIC</span><span class="w">
</span></span></span><span class="line"><span class="ln">55</span><span class="cl"><span class="w">    </span><span class="n">Code</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">56</span><span class="cl"><span class="w">      </span><span class="n">stack</span><span class="o">=</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">locals</span><span class="o">=</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">args_size</span><span class="o">=</span><span class="n">1</span><span class="w">
</span></span></span><span class="line"><span class="ln">57</span><span class="cl"><span class="w">         </span><span class="n">0</span><span class="p">:</span><span class="w"> </span><span class="n">aload_0</span><span class="w">
</span></span></span><span class="line"><span class="ln">58</span><span class="cl"><span class="w">         </span><span class="n">1</span><span class="p">:</span><span class="w"> </span><span class="n">getfield</span><span class="w">      </span><span class="err">#</span><span class="n">2</span><span class="w">                  </span><span class="c1">// Field m:I</span><span class="w">
</span></span></span><span class="line"><span class="ln">59</span><span class="cl"><span class="w">         </span><span class="n">4</span><span class="p">:</span><span class="w"> </span><span class="n">iconst_1</span><span class="w">
</span></span></span><span class="line"><span class="ln">60</span><span class="cl"><span class="w">         </span><span class="n">5</span><span class="p">:</span><span class="w"> </span><span class="n">iadd</span><span class="w">
</span></span></span><span class="line"><span class="ln">61</span><span class="cl"><span class="w">         </span><span class="n">6</span><span class="p">:</span><span class="w"> </span><span class="n">ireturn</span><span class="w">
</span></span></span><span class="line"><span class="ln">62</span><span class="cl"><span class="w">      </span><span class="n">LineNumberTable</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">63</span><span class="cl"><span class="w">        </span><span class="n">line</span><span class="w"> </span><span class="n">8</span><span class="p">:</span><span class="w"> </span><span class="n">0</span><span class="w">
</span></span></span><span class="line"><span class="ln">64</span><span class="cl"><span class="w">      </span><span class="n">LocalVariableTable</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">65</span><span class="cl"><span class="w">        </span><span class="n">Start</span><span class="w">  </span><span class="n">Length</span><span class="w">  </span><span class="n">Slot</span><span class="w">  </span><span class="n">Name</span><span class="w">   </span><span class="n">Signature</span><span class="w">
</span></span></span><span class="line"><span class="ln">66</span><span class="cl"><span class="w">            </span><span class="n">0</span><span class="w">       </span><span class="n">7</span><span class="w">     </span><span class="n">0</span><span class="w">  </span><span class="k">this</span><span class="w">   </span><span class="n">Lcom</span><span class="o">/</span><span class="n">rhythm7</span><span class="o">/</span><span class="n">Main</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">67</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">68</span><span class="cl"><span class="w"></span><span class="nl">SourceFile</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;Main.java&#34;</span><span class="w">
</span></span></span></code></pre></div><h3 id="jvm基础---类的加载过程">JVM基础 - 类的加载过程<a hidden class="anchor" aria-hidden="true" href="#jvm基础---类的加载过程">#</a></h3>
<p>类加载过程包括：<code>加载</code>，<code>验证</code>，<code>准备</code>， <code>解析</code>， <code>初始化</code> 这几个阶段；</p>
<ul>
<li>加载：根据类的全限定名将Class文件加载到<strong>方法区</strong>，并转化为运行时的数据结构；并且在<strong>堆中</strong>生成一个Class对象，作为方法区数据的访问入口</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">clazz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Class</span><span class="p">.</span><span class="na">forName</span><span class="p">(</span><span class="s">&#34;com.example.Demo&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clazz</span><span class="p">.</span><span class="na">getMethod</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过Class对象访问方法区的方法信息</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>连接
<ul>
<li>验证 - 保证被加载的类的<strong>正确性</strong>，校验字节码文件信息</li>
<li>准备 - 为类的<strong>静态变量分配内存</strong>，并初始化默认值（分配在方法区中）</li>
<li>解析 - 把类中的符合引用转换为<strong>直接引用</strong>。</li>
</ul>
</li>
<li>初始化：为类的静态变量赋予正确的初始值
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
</li>
</ul>
<p><strong>类加载器</strong>：</p>
<ul>
<li>
<p>Bootstrap ClassLoader：<strong>启动类加载器</strong>，负责加载存放在<strong>JDK</strong>\jre\lib下，或者被虚拟机识别的<strong>类库</strong>。JDK java.*开头的类</p>
</li>
<li>
<p>Extension ClassLoader：<strong>扩展类加载器</strong>，负责加载JDK\jre\lib\ext目录中的所有库，javax.*开头的类</p>
</li>
<li>
<p>Application ClassLoader：负责加载用户类路径(ClassPath)所指定的类；</p>
</li>
<li>
<p>UserImpl ClassLoader</p>
</li>
</ul>
<p><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>优势：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<hr>
<h3 id="jvm基础---jvm内存结构">JVM基础 - JVM内存结构<a hidden class="anchor" aria-hidden="true" href="#jvm基础---jvm内存结构">#</a></h3>
<p>Java虚拟机(JVM)内存结构是指JVM在<strong>执行Java程序</strong>时所管理的<strong>内存区域划分</strong>，这些内存区域各有<strong>不同的用途</strong>和生命周期。</p>
<p>❗注意：和JMM不是一个东西！</p>
<p><img alt="image-20250428202406497" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428202406497.png"></p>
<ul>
<li>线程私有：程序计数器、虚拟机栈、本地方法区</li>
<li>线程共享：堆、方法区、堆外内存</li>
</ul>
<h4 id="一程序计数器">一、程序计数器<a hidden class="anchor" aria-hidden="true" href="#一程序计数器">#</a></h4>
<p><strong>作用</strong>：记录 JVM 字节码下一条执行的指令地址。</p>
<p><strong>扩展</strong>：因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<h4 id="二虚拟机栈">二、虚拟机栈<a hidden class="anchor" aria-hidden="true" href="#二虚拟机栈">#</a></h4>
<p><strong>作用</strong>：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。<strong>每个线程</strong>都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong>。<u>每个方法都各自有对应的一个栈帧。</u></p>
<p><strong>栈帧</strong> - 方法调用和执行的基本单位</p>
<ul>
<li><strong>局部变量</strong>表：方法内定义的局部变量</li>
<li><strong>操作数</strong>栈：用于<strong>方法执行时的计算</strong>，存储<strong>临时数据</strong>（如算术运算、<strong>方法参数传递</strong>）
<ul>
<li>可理解为草稿纸，函数中执行的计算，不可能一步完成，可能需要多步记录，这个栈可以用来暂存信息或函数调用时传参数。</li>
</ul>
</li>
<li>动态链接：存储<strong>指向运行时常量池（Runtime Constant Pool）的引用</strong>，用于<strong>方法调用时的符号解析</strong> 【符合引用修改为内存中的入口地址-直接引用】
<ul>
<li>存储<strong>方法在运行时常量池中的引用</strong>，用于支持<strong>多态方法调用</strong>（如接口方法、重写方法）；运行时才链接实际调用的方法(支持多态)；</li>
</ul>
</li>
<li>方法返回地址：存储<strong>方法执行完毕后返回的位置</strong>（调用者的程序计数器 PC 值）</li>
<li>附加信息。</li>
</ul>
<h4 id="三堆内存">三、堆内存<a hidden class="anchor" aria-hidden="true" href="#三堆内存">#</a></h4>
<p><strong>作用：</strong> 存放对象的实例。被所有线程共享。</p>
<p><strong>高效回收：</strong> 将堆内存逻辑上分为三块 <strong><u>（优化GC的性能）</u></strong></p>
<ul>
<li>新生代：新对象和没到一定年龄的对象都放在新生代；</li>
<li>老年代：被长时间使用的对象；</li>
<li>元空间：</li>
</ul>
<p><strong>具体：</strong></p>
<ul>
<li>
<p>新生代：</p>
<ul>
<li>伊甸园区(Eden Memory) + 两个幸存区(Survivor Memory), 默认比例是 8:1:1</li>
<li>大多数对象创建的时候都放置在Eden内存空间中；(首次)</li>
<li>当Eden区被填充满，会执行Minor GC，将幸存的对象移动到一个幸存区中；</li>
<li>两个两个幸存区使用的是复制算法；</li>
<li>经过多轮Minor GC仍存活的对象会复制到 Eden区。默认是15次，因为这个标识使用4个比特；</li>
</ul>
</li>
<li>
<p>老年代</p>
<ul>
<li>存放多次Minor GC仍存活的对象。当老年代内存满了，会执行Major GC</li>
<li>大的对象，占据大量连续内存的对象会直接放入到老年代中，避免在两个幸存区中进行大量的内存拷贝；</li>
</ul>
</li>
<li>
<p>设置JVM堆内存大小</p>
<ul>
<li>-Xms来设置堆的起始内存</li>
<li>-Xmx来设置堆的最大内存</li>
</ul>
</li>
</ul>
<p><strong>对象在堆中的生命周期</strong></p>
<ol>
<li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代
<ul>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ul>
</li>
<li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区
<ul>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
</li>
<li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）
<ul>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ul>
</li>
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会**直接被分配到老年代</li>
</ol>
<h4 id="四方法区">四、方法区<a hidden class="anchor" aria-hidden="true" href="#四方法区">#</a></h4>
<p>目的：存放<strong>已被加载的类信息、常量、静态变量、即时编译器编译后的代码</strong></p>
<ol>
<li><strong>类信息的仓库</strong>：存储加载的类的元数据（字段、方法、常量池等）
<ol>
<li>常量池：字面量(&ldquo;abc&rdquo;,123, final常量) 和 符号引用(类和接口的全限定名+字段和方法名称和描述符)</li>
<li>运行时常量池：类加载时，将常量池转变为运行时常量池。主要就是修改符号引用，调整为直接引用(内存实际地址)，运行时动态添加常量(String.intern())</li>
</ol>
</li>
<li><strong>静态变量的家</strong>：存放 <code>static</code> 变量和编译期常量。</li>
<li><strong>JIT 的缓存</strong>：存储热点代码的本地机器码。</li>
<li><strong>动态性的基石</strong>：支持反射、动态代理等高级特性</li>
</ol>
<h4 id="五本地方法栈">五、本地方法栈<a hidden class="anchor" aria-hidden="true" href="#五本地方法栈">#</a></h4>
<p>**目的：**用于支持 <strong>Native 方法（本地方法）</strong> 的执行。非Java语言的方法，例如操作系统提供的方法；原理与虚拟机栈类似</p>
<h3 id="jvm基础---jmm-java-内存模型">❌JVM基础 - JMM (Java 内存模型)<a hidden class="anchor" aria-hidden="true" href="#jvm基础---jmm-java-内存模型">#</a></h3>
<p>现在的电脑：CPU - Cache - 内存三级架构，并且CPU是多核的。这样的话，线程之间可能是同时运行的。</p>
<p><strong>会导致两个问题</strong></p>
<ul>
<li>两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。(CPU将结果存储在Cache中，并没有及时的写回内存)
<ul>
<li>volatile 确保线程修改共享变量后对其他线程立即可见</li>
</ul>
</li>
<li>两个线程将共享对象的变量计数读入其CPU缓存中，例如初始为1，每个线程自增1，同步的情况下应该为3，但是未合理同步导致为2.
<ul>
<li>使用Java synchronized块, 保证同一时间只有一个线程可以进入临界资源。</li>
</ul>
</li>
</ul>
<p><strong>JMM基础</strong></p>
<p>定义：定义了线程如何与内存交互，以及线程之间如何通过内存进行通信。</p>
<p><img alt="image-20250506111746427" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250506111746427.png"></p>
<p>核心概念：</p>
<ul>
<li>主内存和工作内存
<ul>
<li>主内存：共享变量</li>
<li>工作内存：线程私有的内存区域，存放局部变量和共享变量副本</li>
</ul>
</li>
<li>内存间交互操作
<ul>
<li>从主内存读取共享变量的线程工作内存</li>
<li>线程将工作内存的共享变量写回主内存</li>
</ul>
</li>
<li><strong>happens-before原则</strong> (重排序)
<ul>
<li>编译器和处理器常常会对指令做重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。提高执行效率</li>
<li>这些重排序都可能会导致多线程程序出现内存可见性问题</li>
<li>插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序</li>
</ul>
</li>
</ul>
<p>JMM带来的问题</p>
<ul>
<li>可见性
<ul>
<li><strong>volatile</strong>关键字，读取和修改都及时从内存中进行读写，保证修改的结果对其他线程及时可见</li>
</ul>
</li>
<li>有序性
<ul>
<li>synchronized、<strong>concurrent包</strong>提供的，原子类和锁机制实现。</li>
</ul>
</li>
<li>原子性
<ul>
<li><strong>synchronized</strong>关键字进行加锁，通过互斥实现线程安全；</li>
</ul>
</li>
</ul>
<h3 id="gc-垃圾回收">GC 垃圾回收<a hidden class="anchor" aria-hidden="true" href="#gc-垃圾回收">#</a></h3>
<p>**目的：**释放掉不使用了的内存空间，主要针对的是堆和方法区</p>
<h4 id="判断一个对象是否可以被回收">判断一个对象是否可以被回收<a hidden class="anchor" aria-hidden="true" href="#判断一个对象是否可以被回收">#</a></h4>
<ul>
<li>引用计数
<ul>
<li>给对象添加一个引用计数器，每被引用一次则+1。当值为0表示没有被其他对象引用，可以回收</li>
<li>缺点：会产生循环引用的情况，就是对象A引用对象B，对象B引用对象A，但是这俩对象都不再使用，但是无法回收，导致内存泄漏。</li>
</ul>
</li>
<li>可达性分析
<ul>
<li>通过 GC root作为起始点进行搜索，能够到达的对象都是存活对象，不可达的对象会被回收。</li>
<li>GC root对象一般包括：
<ul>
<li>虚拟机栈、本地方法栈、方法区静态属性、方法区常量引用中引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类的卸载条件：(需要满足以下三点，且满足了也不一定回收)</p>
<ul>
<li>所有实例被回收</li>
<li>对应的类加载器被回收</li>
<li>类的Class对象被回收，那么在任何地方都无法通过Class对象反射访问该类方法</li>
</ul>
<h4 id="引用类型">引用类型<a hidden class="anchor" aria-hidden="true" href="#引用类型">#</a></h4>
<ul>
<li>强引用: 被强关联的对象</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Object</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>软引用：只有内存空间不足时才会被回收；使用场景：外部资源，比如图片缓存等&hellip; 可以再次获取。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Object</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">  </span><span class="c1">// 使对象只被软引用关联</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用场景：临时缓存</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Object</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Object</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h4 id="垃圾回收算法">垃圾回收算法<a hidden class="anchor" aria-hidden="true" href="#垃圾回收算法">#</a></h4>
<ul>
<li>标记 - 清除
<ul>
<li>标记存活的对象，清理掉未被标记的对象</li>
</ul>
</li>
</ul>
<p><img alt="image-20250428213710917" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428213710917.png"></p>
<ul>
<li>标记 - 整理<img alt="image-20250428213740094" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428213740094.png">
<ul>
<li>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li>
</ul>
</li>
<li>标记 - 复制
<ul>
<li>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</li>
</ul>
</li>
</ul>
<p><img alt="image-20250428213806913" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428213806913.png"></p>
<ul>
<li>分代回收
<ul>
<li>一般将堆分为新生代和老年代。
<ul>
<li>新生代使用: 标记 - 复制算法</li>
<li>老年代使用: 标记 - 整理 算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾收集器">垃圾收集器<a hidden class="anchor" aria-hidden="true" href="#垃圾收集器">#</a></h4>
<p>设计目标：<strong>吞吐量</strong> or <strong>延迟</strong></p>
<p><img alt="image-20250428213937801" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428213937801.png"></p>
<p><img alt="image-20250428214942234" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428214942234.png"></p>
<ul>
<li>Serial new + old 收集器  ˈsɪəriəl
<ul>
<li><strong>串行</strong>进行垃圾回收。<strong>单CPU环境下性能高</strong>，因为没有上下文切换的开销。会存在stop the world 死区。</li>
<li>年轻代-<strong>标记复制</strong>；老年代-<strong>标记整理</strong></li>
</ul>
</li>
</ul>
<p><img alt="image-20250428220451369" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428220451369.png"></p>
<ul>
<li>Parallel Scavenge + Parallel Old收集器  ˈpærəlel ˈskævɪndʒ
<ul>
<li>Serial的多线程版</li>
<li>年轻代-<strong>标记复制</strong>(多线程)；老年代-<strong>标记整理</strong>(多线程)</li>
</ul>
</li>
</ul>
<p>ParNew：<img alt="image-20250428220851117" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428220851117.png"></p>
<p>CMS： Concurrent Mark Sweep   swiːp<img alt="image-20250428220322299" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428220322299.png"></p>
<ul>
<li>ParNew - CMS 收集器
<ul>
<li>为了配合CMS产生的ParNew</li>
<li>年轻代-多线程复制；老年代-<strong>并发标记-清除</strong>(CMS)</li>
<li>CMS收集器： <strong>降低延迟</strong>
<ul>
<li><strong>初始标记</strong>: 仅仅只是<strong>标记一下 GC Roots 能<code>直接</code>关联到的对象</strong>，速度很快（只扫第一层引用），需要停顿。 <strong>STW暂停</strong></li>
<li><strong>并发标记</strong>: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。(****递归标记<strong>所有存活对象（从初始标记的对象出发，遍历整个对象图）</strong>)  让GC和用户线程<strong>交替工作</strong>，减少停顿时间</li>
<li><strong>重新标记</strong>: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。(<strong>修正并发标记期间的引用变化</strong>) <strong>STW暂停</strong>  (卡表标记变更的区域)</li>
<li><strong>并发清除</strong>: 不需要停顿。</li>
</ul>
</li>
</ul>
</li>
<li>G1 收集器
<ul>
<li>新生代：分区复制 + 标记-整理</li>
<li>老年代：分区标记-整理</li>
</ul>
</li>
</ul>
<p><img alt="image-20250428222244144" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428222244144.png"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。<strong>通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</strong></p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img alt="image-20250428222229462" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250428222229462.png"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记：</li>
<li>并发标记</li>
<li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点:</p>
<ul>
<li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<hr>
<h4 id="内存分配和回收策略">内存分配和回收策略<a hidden class="anchor" aria-hidden="true" href="#内存分配和回收策略">#</a></h4>
<ul>
<li>
<p>Minor GC、Major GC、 Full GC</p>
<ul>
<li>
<p>Minor GC: 收集新生代垃圾</p>
</li>
<li>
<p>Major GC： 收集老年代垃圾</p>
</li>
<li>
<p>Mixed GC：G1收集器，收集新生代垃圾和部分老年代垃圾</p>
</li>
<li>
<p>Full GC：收集整个堆和方法区垃圾</p>
</li>
</ul>
</li>
<li>
<p>内存分配策略</p>
<ul>
<li>对象优先在Eden区分配
<ul>
<li>当Eden区内存不足，发起minor GC</li>
</ul>
</li>
<li>大对象直接进老年代
<ul>
<li>避免在Eden区和survivor区之间的大量内存复制</li>
</ul>
</li>
<li>长期存活对象进老年代
<ul>
<li>默认minor gc 15次之后</li>
</ul>
</li>
<li>动态年龄判断：当Survivor 中相同年龄所有对象大小总和超过一般的Survivor区，将大于等于该年龄的对象移动到老年代中；</li>
</ul>
</li>
<li>
<p>Full GC触发条件</p>
<ul>
<li>调用System.gc()：手动调用，只是建议并不一定执行。不推荐</li>
<li>老年代空间不足</li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://longcoding.top/posts/learning/paper_reading2/">
    <span class="title">« Prev</span>
    <br>
    <span>深度学习论文汇总2</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://longcoding.top/">LongCoding&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
