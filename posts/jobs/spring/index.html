<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Spring笔记 | LongCoding&#39;s Blog</title>
<meta name="keywords" content="spring">
<meta name="description" content="1. 什么是循环依赖
两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。
=&gt; 多个Bean循环引用导致Spring容器无法正常初始化它们。
延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。
2. Spring如何解决循环依赖
提前暴露未完全创建的Bean
三级缓存解决：

一级缓存(Single Objects Map)：用于初始化单例Bean； (成品)
二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化)
三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean

**解决步骤：**例如AB两个相互依赖，三级缓存策略

创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)；
之后，A往三级缓存加入一个A的getObject方法
到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。
回到A，A调用一级缓存的B完成注入。

未解决的问题：
而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。
4. Spring重要的模块组成
Core Container 核心容器：

Spring Core：提供依赖注入DI和控制反转IOC的实现。
Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作；
Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能；
Spring Expression Language：用于运行时查询和操作对象的值。

AOP面向切面编程

Spring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。

Data Access 数据访问">
<meta name="author" content="LongWei">
<link rel="canonical" href="http://longcoding.top/posts/jobs/spring/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://longcoding.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://longcoding.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://longcoding.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://longcoding.top/apple-touch-icon.png">
<link rel="mask-icon" href="http://longcoding.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://longcoding.top/posts/jobs/spring/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://longcoding.top/posts/jobs/spring/">
  <meta property="og:site_name" content="LongCoding&#39;s Blog">
  <meta property="og:title" content="Spring笔记">
  <meta property="og:description" content="1. 什么是循环依赖 两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。
=&gt; 多个Bean循环引用导致Spring容器无法正常初始化它们。
延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。
2. Spring如何解决循环依赖 提前暴露未完全创建的Bean
三级缓存解决：
一级缓存(Single Objects Map)：用于初始化单例Bean； (成品) 二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化) 三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean **解决步骤：**例如AB两个相互依赖，三级缓存策略
创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)； 之后，A往三级缓存加入一个A的getObject方法 到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。 回到A，A调用一级缓存的B完成注入。 未解决的问题：
而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。
4. Spring重要的模块组成 Core Container 核心容器：
Spring Core：提供依赖注入DI和控制反转IOC的实现。 Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作； Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能； Spring Expression Language：用于运行时查询和操作对象的值。 AOP面向切面编程
Spring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。 Data Access 数据访问">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-01T00:00:00+00:00">
    <meta property="article:tag" content="Spring">
      <meta property="og:image" content="http://longcoding.top/papermod-cover.png">
      <meta property="og:see_also" content="http://longcoding.top/posts/jobs/collection/">
      <meta property="og:see_also" content="http://longcoding.top/posts/jobs/jvm/">
      <meta property="og:see_also" content="http://longcoding.top/posts/jobs/juc/">
      <meta property="og:see_also" content="http://longcoding.top/posts/jobs/mysql/">
      <meta property="og:see_also" content="http://longcoding.top/posts/jobs/redis/">
      <meta property="og:see_also" content="http://longcoding.top/posts/jobs/java/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://longcoding.top/papermod-cover.png">
<meta name="twitter:title" content="Spring笔记">
<meta name="twitter:description" content="1. 什么是循环依赖
两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。
=&gt; 多个Bean循环引用导致Spring容器无法正常初始化它们。
延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。
2. Spring如何解决循环依赖
提前暴露未完全创建的Bean
三级缓存解决：

一级缓存(Single Objects Map)：用于初始化单例Bean； (成品)
二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化)
三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean

**解决步骤：**例如AB两个相互依赖，三级缓存策略

创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)；
之后，A往三级缓存加入一个A的getObject方法
到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。
回到A，A调用一级缓存的B完成注入。

未解决的问题：
而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。
4. Spring重要的模块组成
Core Container 核心容器：

Spring Core：提供依赖注入DI和控制反转IOC的实现。
Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作；
Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能；
Spring Expression Language：用于运行时查询和操作对象的值。

AOP面向切面编程

Spring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。

Data Access 数据访问">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://longcoding.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Spring笔记",
      "item": "http://longcoding.top/posts/jobs/spring/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring笔记",
  "name": "Spring笔记",
  "description": "1. 什么是循环依赖 两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。\n=\u0026gt; 多个Bean循环引用导致Spring容器无法正常初始化它们。\n延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。\n2. Spring如何解决循环依赖 提前暴露未完全创建的Bean\n三级缓存解决：\n一级缓存(Single Objects Map)：用于初始化单例Bean； (成品) 二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化) 三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean **解决步骤：**例如AB两个相互依赖，三级缓存策略\n创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)； 之后，A往三级缓存加入一个A的getObject方法 到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。 回到A，A调用一级缓存的B完成注入。 未解决的问题：\n而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。\n4. Spring重要的模块组成 Core Container 核心容器：\nSpring Core：提供依赖注入DI和控制反转IOC的实现。 Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作； Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能； Spring Expression Language：用于运行时查询和操作对象的值。 AOP面向切面编程\nSpring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。 Data Access 数据访问\n",
  "keywords": [
    "spring"
  ],
  "articleBody": "1. 什么是循环依赖 两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。\n=\u003e 多个Bean循环引用导致Spring容器无法正常初始化它们。\n延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。\n2. Spring如何解决循环依赖 提前暴露未完全创建的Bean\n三级缓存解决：\n一级缓存(Single Objects Map)：用于初始化单例Bean； (成品) 二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化) 三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean **解决步骤：**例如AB两个相互依赖，三级缓存策略\n创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)； 之后，A往三级缓存加入一个A的getObject方法 到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。 回到A，A调用一级缓存的B完成注入。 未解决的问题：\n而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。\n4. Spring重要的模块组成 Core Container 核心容器：\nSpring Core：提供依赖注入DI和控制反转IOC的实现。 Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作； Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能； Spring Expression Language：用于运行时查询和操作对象的值。 AOP面向切面编程\nSpring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。 Data Access 数据访问\nSpring JDBC：操作数据库 Spring ORM：支持注意ORM框架，简化持久层开发 Spring Transaction事务管理：提供声明式事务和编程式的事务管理机制 Web层\nSpring Web：提供基础Web开发支持，包括Servlet Api的集成\nSpring MVC：实现了Model-View——Controller(MVC)模式的框架，用于构建HTTP请求的Web应用；\n5. Spring IOC 控制反转，通过依赖注入让容器负责管理对象的创建和管理\n核心：对象的创建和依赖关系交由IOC容器进行负责。 依赖注入：构造器注入，setter注入或接口注入。 控制：控制对象的创建过程\n反转：创建对象的主题变为Spring\n6. Spring Bean Spring应用中的对象\n生命周期\n实例化 依赖注入：将依赖的其他对象注入进来 初始化：如果Bean实现了Initializing接口或者@PostConstruct，Spring依赖注入后会调用该初始化方法； 销毁 创建方式：\nXML配置 基于注解：@Component @Service @Repository @Controller等 Java配置类：通过结合@Configuration和@Bean实现 7. Spring注入方式 构造器注入 setter注入 字段注入 @Autowired 方法注入 @Autowired 接口回调注入：注入实现类 8. AOP面向切面 核心：将与业务逻辑无关的横切关注点抽取出来，通过声明式动态的应用到业务方法中，而不是嵌入业务逻辑中。\n关键概念：切面(Aspect)、连接点(Joint Point)、通知(advice)、切入点(PointCut)和织入(Weaving)\n1@Aspect 2@Component 3public class LoggingAspect { 4 5 @Before(\"execution(* UserService.createUser(..))\") 6 public void logBefore() { 7 System.out.println(\"准备创建用户...\"); 8 } 9} 9. Spring拦截链的实现 责任链模式，指一系列拦截器依次生效\nHandlerInterceptor（MVC拦截器）：用于拦截HTTP请求 Filter（过滤器）：基于Servlet API的过滤器 AOP拦截链（切面）：实现方法的前后处理。@Before @After @Around 💡在Spring AOP中，@before和@after注解都对应一个Interceptor拦截器，\n责任链模式\n10. Spring MVC知识点 基于经典的MVC模式 (Model-View-Controller)来开发Web应用的模块。\n基于Servlet API构建，核心是DispatcherServlet, 即请求分发器，将HTTP请求映射到控制器方法中，并将数据返回给视图层进行渲染\nModel：业务模型和数据模型 分别是Servie、Repository；\nController：分别是DispatcherServlet和Controller；(分发\u0026处理)\n主要功能： 请求映射、数据绑定、视图解析、表单处理、异常处理等。\n工作流程：\nHTTP请求 =\u003e DispatcherServlet 根据URL进行分发 HandlerMapping：缓存URL到具体处理器对象的映射关系 HandlerAdapter：DispatcherServlet通过该适配器间接调用Handler URL =\u003e Controller 接收请求并进行业务处理 ModelAndView：数据封装到模型对象中。 ViewResolver:负责呈现数据，前后端分离，不需要这个。 11. Spring MVC的具体工作原理 DispatcherServlet接收请求\n请求映射：根据请求URL查询HandlerMapping，返回Handler执行链(拦截器和处理器)\n依次执行拦截器preHandle()xN=\u003eController，若中断则直接转到afterComplete()\n获取HandlerAdapter：通过HandlerAdapter执行handle方法，解决不同处理器的差异\n拦截器postHandle()\nAfterCompletion()\n返回响应数据\n12. Spring中的设计模式 工厂模式：BeanFactory\n模板方法：RestTemplate、JDBCTemplate，RedisStringTemplate\n代理模式：AOP\n单例模式：IOC下的Bean\n责任链模式：SpringMVC拦截器\n观察者模式：Spring中的监听器\n适配器模式：handlerAdapter\n13 Spring中的事务传播行为 父事务与子事务之间的关系？一个事务被另一个事务调用\n作用：定义和管理事务边界，定义多个事务方法嵌套时，是否开启新事务、复用事务还是挂起事务。。。\nPropagation_Required 必须传播 最常用的事务传播行为，如果存在事务，执行的方法会加入到该事务中，若不存在，则会创建一个新事务； 例如下单场景，扣减库存、生产订单记录、更新用户积分等多个操作，应该在一个事务中，以保证数据的一致性 Propagation_SUPPORTS 支持的传播行为 当前存在事务则加入，否则非事务方式执行 例如电商场景下，用户查看商品评论列表，这是正常操作。但是在一个事务中调用该方法(进行商品推广活动统计时，同时查看商品评论列表)，则可以加入该事务。 Propagation_MANDATORY 强制的传播行为 必须要求存在当前事务，否则抛出异常 场景：促销活动中，进行优惠计算并更新订单金额和扣减库存时，必须在同一个事务中。因为这两是紧密关联的。 Propagation_REQUIRES_NEW 需要新事务的传播行为 无论是否存在事务，调用的子方法都会创建一个新的事务。 独立小团体 例子：业务操作和日志操作，这俩相对独立的操作，即使业务失败，日志也应该成功 Propagation_NOT_SUPPORTED 不支持事务的传播行为 子方法以非事务的方式执行，若存在事务，先挂起 场景：xxx Propagation_NERVER 不允许事务的传播 要求当前绝对不能存在事务，否则抛出异常 例如: 计算商品的推荐指数时，不涉及事务操作 Propagation_NESTED 嵌套传播行为 若当前存在事务，方法将在嵌套事务中执行，否则创建新事务 例子：多个步骤，检查库存，生成订单，发送通知等。生成订单时异常，仅回滚这个子事务，不影响前面的检查库存操作。 14. Spring IOC容器初始化过程 四阶段\n启动阶段 配置加载：加载配置文件or配置类，XML配置文件、JAVA配置类或配置注解 创建容器：Spring创建IOC容器(BeanFactory\\ApplicationContext), 加载和管理Bean Bean定义和注册阶段 解析Bean定义，注册到容器中 实例化和依赖注入 实例化：根据BeanDefinition创建Bean实例 依赖注入：根据构造函数、Setter方法、字段注入，将依赖注入到Bean中 初始化 BeanPostProcessor：处理器会在Bean初始化完成后执行 @Post Construct Bean的初始化方法 15 Qualifier注解 例如：当多个接口有多个实现时，指定哪个具体的Bean，消除歧义\n1@Component 2public class Client { 3 4 private final Service service; 5 6 @Autowired 7 public Client(@Qualifier(\"serviceImpl1\") Service service) { 8 this.service = service; 9 } 10 11 public void doSomething() { 12 service.serve(); 13 } 14} @Primary 多个Bean实现了继承了某个类，依赖注入优先为带有@Primary的类\n1@Component 2@Primary 3public class DefaultService implements Service { 4 public void serve() { 5 System.out.println(\"Default Service\"); 6 } 7} 8 9@Component 10@Qualifier(\"specificService\") 11public class SpecificService implements Service { 12 public void serve() { 13 System.out.println(\"Specific Service\"); 14 } 15} 16 17@Component 18public class Client { 19 20 private final Service service; 21 22 @Autowired 23 public Client(@Qualifier(\"specificService\") Service service) { 24 this.service = service; 25 } 26 27 public void doSomething() { 28 service.serve(); 29 } 30} 16 事务的失效场景 使用@Transactional声明式事务时，存在以下事务失效情况\n⭐rollbackFor：没设置对，默认为(RuntimeException or Error回滚才生效)，而自定义异常和IOException等并不会回滚\n1@Transactional(rollbackFor = Exception.class) ⭐异常被捕获了，异常被catch了，仅打印log，并没有将异常往回抛出。\n⭐同一个类中方法调用，因为事务是基于动态代理实现的，自己调用自己的方法不会走代理方法\n只有通过代理对象调用的方法才会被事务拦截器增强 当类内部方法A调用方法B时，实际上是this.methodB()调用，而不是proxy.methodB() 1((XXXService)AopContext.currentProxy()) 2 .applyMethod(xxx); @Transactional应用在非public修饰上，Spring事务判断非公开方法不执行事务\n⭐事务传播设置不当，设置为Requires_new，会创建子事务，两个无关\n多线程环境，@Transactional基于ThreadLocal，因此多线程不能保持事务同步。\n17. Spring 启动过程 创建\u003c容器\u003e： 根据配置文件中的信息创建容器 ApplicationContext，容器启动阶段实例化BeanFactory，并加载容器总的BeanDefinitions 加载\u003c配置\u003e： 读取XML配置文件，JAVA Config类，和基于注解的Bean，包括数据库连接配置、AOP配置等等。 注册Bean\u003c定义\u003e 解析配置文件中定义的BeanDefinition和声明的Bean元数据 **\u003c实例化\u003e**Bean：实例化Bean对象，并放入容器中进行管理 \u003c注入依赖\u003e： 注入Bean对象中的依赖对象，构造器，setter，字段注入 \u003c初始化\u003eBean InitializingBean，or afterPropertiesSet ? 这是什么呢 \u0026 BeanPostProcessors 18. @Value注解 注入外部资源的值\n配置文件注入 例子：\n1app.name=MyApp 2app.version=1.0.0 1import org.springframework.beans.factory.annotation.Value; 2import org.springframework.stereotype.Component; 3 4@Component 5public class AppConfig { 6 7 @Value(\"${app.name}\") 8 private String appName; 9 10 @Value(\"${app.version}\") 11 private String appVersion; 12 13 public String getAppName() { 14 return appName; 15 } 16 17 public String getAppVersion() { 18 return appVersion; 19 } 20} 19 常用的注解 @PostConstruct：Bean初始化完成后调用\n提前加载数据 @PreDestory： Bean销毁前调用\n关闭连接，释放资源 @Scheduled 定时任务\n@Conditional 有条件的装配Bean对象\n1@Conditional(OnLinuxCondition.class) // 仅这个类存在时才装配这个Bean到容器中 2@Bean 3public MyService myService() { 4 return new MyService(); 5} @ControllerAdvice 全局异常处理\n1@ControllerAdvice 2public class GlobalExceptionHandler { 3 4 @ExceptionHandler(Exception.class) 5 public ResponseEntity\u003cString\u003e handleAllExceptions(Exception ex) { 6 return new ResponseEntity\u003c\u003e(\"An error occurred: \" + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); 7 } 8} ",
  "wordCount" : "516",
  "inLanguage": "en",
  "image": "http://longcoding.top/papermod-cover.png","datePublished": "2025-03-01T00:00:00Z",
  "dateModified": "2025-03-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "LongWei"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://longcoding.top/posts/jobs/spring/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LongCoding's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://longcoding.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://longcoding.top/" accesskey="h" title="𝓛𝓸𝓷𝓰𝓒𝓸𝓭𝓲𝓷𝓰 (Alt + H)">
                <img src="http://longcoding.top/android-icon-48x48.png" alt="" aria-label="logo"
                    height="30">𝓛𝓸𝓷𝓰𝓒𝓸𝓭𝓲𝓷𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://longcoding.top/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/archives/" title="📃 Archives">
                    <span>📃 Archives</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/categories/" title="🗒️ Categories">
                    <span>🗒️ Categories</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://longcoding.top/about/" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://longcoding.top/">Home</a>&nbsp;»&nbsp;<a href="http://longcoding.top/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Spring笔记
    </h1>
    <div class="post-meta"><span title='2025-03-01 00:00:00 +0000 UTC'>March 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;516 words&nbsp;·&nbsp;LongWei

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e4%bb%80%e4%b9%88%e6%98%af%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" aria-label="1. 什么是循环依赖">1. 什么是循环依赖</a></li>
                <li>
                    <a href="#2-spring%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" aria-label="2. Spring如何解决循环依赖">2. Spring如何解决循环依赖</a></li>
                <li>
                    <a href="#4-spring%e9%87%8d%e8%a6%81%e7%9a%84%e6%a8%a1%e5%9d%97%e7%bb%84%e6%88%90" aria-label="4. Spring重要的模块组成">4. Spring重要的模块组成</a></li>
                <li>
                    <a href="#5-spring-ioc" aria-label="5. Spring IOC">5. Spring IOC</a></li>
                <li>
                    <a href="#6-spring-bean" aria-label="6. Spring Bean">6. Spring Bean</a></li>
                <li>
                    <a href="#7-spring%e6%b3%a8%e5%85%a5%e6%96%b9%e5%bc%8f" aria-label="7. Spring注入方式">7. Spring注入方式</a></li>
                <li>
                    <a href="#8-aop%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2" aria-label="8. AOP面向切面">8. AOP面向切面</a></li>
                <li>
                    <a href="#9-spring%e6%8b%a6%e6%88%aa%e9%93%be%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="9. Spring拦截链的实现">9. Spring拦截链的实现</a></li>
                <li>
                    <a href="#10-spring-mvc%e7%9f%a5%e8%af%86%e7%82%b9" aria-label="10. Spring MVC知识点">10. Spring MVC知识点</a></li>
                <li>
                    <a href="#11-spring-mvc%e7%9a%84%e5%85%b7%e4%bd%93%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="11. Spring MVC的具体工作原理">11. Spring MVC的具体工作原理</a></li>
                <li>
                    <a href="#12-spring%e4%b8%ad%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="12. Spring中的设计模式">12. Spring中的设计模式</a></li>
                <li>
                    <a href="#13-spring%e4%b8%ad%e7%9a%84%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba" aria-label="13 Spring中的事务传播行为">13 Spring中的事务传播行为</a></li>
                <li>
                    <a href="#14-spring-ioc%e5%ae%b9%e5%99%a8%e5%88%9d%e5%a7%8b%e5%8c%96%e8%bf%87%e7%a8%8b" aria-label="14. Spring IOC容器初始化过程">14. Spring IOC容器初始化过程</a></li>
                <li>
                    <a href="#15-qualifier%e6%b3%a8%e8%a7%a3" aria-label="15 Qualifier注解">15 Qualifier注解</a></li>
                <li>
                    <a href="#16-%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%a4%b1%e6%95%88%e5%9c%ba%e6%99%af" aria-label="16 事务的失效场景">16 事务的失效场景</a></li>
                <li>
                    <a href="#17-spring-%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b" aria-label="17. Spring 启动过程">17. Spring 启动过程</a></li>
                <li>
                    <a href="#18-value%e6%b3%a8%e8%a7%a3" aria-label="18. @Value注解">18. @Value注解</a></li>
                <li>
                    <a href="#19-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%b3%a8%e8%a7%a3" aria-label="19 常用的注解">19 常用的注解</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="1-什么是循环依赖">1. 什么是循环依赖<a hidden class="anchor" aria-hidden="true" href="#1-什么是循环依赖">#</a></h3>
<p>两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。</p>
<p>=&gt; 多个Bean循环引用导致Spring容器无法正常初始化它们。</p>
<p>延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。</p>
<h3 id="2-spring如何解决循环依赖">2. Spring如何解决循环依赖<a hidden class="anchor" aria-hidden="true" href="#2-spring如何解决循环依赖">#</a></h3>
<p><strong>提前暴露未完全创建的Bean</strong></p>
<p>三级缓存解决：</p>
<ul>
<li>一级缓存(Single Objects Map)：用于初始化单例Bean； (成品)</li>
<li>二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化)</li>
<li>三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean</li>
</ul>
<p>**解决步骤：**例如AB两个相互依赖，三级缓存策略</p>
<ul>
<li>创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)；</li>
<li>之后，A往<strong>三级缓存</strong>加入一个A的getObject方法</li>
<li>到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。</li>
<li>回到A，A调用一级缓存的B完成注入。</li>
</ul>
<p>未解决的问题：</p>
<p>而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。</p>
<h3 id="4-spring重要的模块组成">4. Spring重要的模块组成<a hidden class="anchor" aria-hidden="true" href="#4-spring重要的模块组成">#</a></h3>
<p><strong>Core Container 核心容器：</strong></p>
<ul>
<li>Spring Core：提供依赖注入DI和控制反转IOC的实现。</li>
<li>Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作；</li>
<li>Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能；</li>
<li>Spring Expression Language：用于运行时查询和操作对象的值。</li>
</ul>
<p><strong>AOP面向切面编程</strong></p>
<ul>
<li>Spring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。</li>
</ul>
<p><strong>Data Access 数据访问</strong></p>
<ul>
<li>Spring JDBC：操作数据库</li>
<li>Spring ORM：支持注意ORM框架，简化持久层开发</li>
<li>Spring Transaction事务管理：提供声明式事务和编程式的事务管理机制</li>
</ul>
<p><strong>Web层</strong></p>
<ul>
<li></li>
<li>
<p>Spring Web：提供基础Web开发支持，包括Servlet Api的集成</p>
</li>
<li>
<p>Spring MVC：实现了Model-View——Controller(MVC)模式的框架，用于构建HTTP请求的Web应用；</p>
</li>
</ul>
<p><img alt="image-20250415185859345" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415185859345.png"></p>
<h3 id="5-spring-ioc">5. Spring IOC<a hidden class="anchor" aria-hidden="true" href="#5-spring-ioc">#</a></h3>
<p>控制反转，通过依赖注入让容器负责管理对象的创建和管理</p>
<ul>
<li>核心：对象的创建和依赖关系交由IOC容器进行负责。</li>
<li>依赖注入：构造器注入，setter注入或接口注入。</li>
</ul>
<p>控制：控制对象的创建过程</p>
<p>反转：创建对象的主题变为Spring</p>
<h3 id="6-spring-bean">6. Spring Bean<a hidden class="anchor" aria-hidden="true" href="#6-spring-bean">#</a></h3>
<p>Spring应用中的对象</p>
<p>生命周期</p>
<ul>
<li>实例化</li>
<li>依赖注入：将依赖的其他对象注入进来</li>
<li>初始化：如果Bean实现了Initializing接口或者@PostConstruct，Spring依赖注入后会调用该初始化方法；</li>
<li>销毁</li>
</ul>
<p>创建方式：</p>
<ul>
<li>XML配置</li>
<li>基于注解：@Component @Service @Repository @Controller等</li>
<li>Java配置类：通过结合@Configuration和@Bean实现</li>
</ul>
<h3 id="7-spring注入方式">7. Spring注入方式<a hidden class="anchor" aria-hidden="true" href="#7-spring注入方式">#</a></h3>
<ul>
<li>构造器注入</li>
<li>setter注入</li>
<li>字段注入 @Autowired</li>
<li>方法注入 @Autowired</li>
<li>接口回调注入：注入实现类</li>
</ul>
<h3 id="8-aop面向切面">8. AOP面向切面<a hidden class="anchor" aria-hidden="true" href="#8-aop面向切面">#</a></h3>
<ul>
<li>
<p>核心：将与业务逻辑无关的横切关注点抽取出来，通过声明式动态的应用到业务方法中，而不是嵌入业务逻辑中。</p>
</li>
<li>
<p>关键概念：切面(Aspect)、连接点(Joint Point)、通知(advice)、切入点(PointCut)和织入(Weaving)</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="nd">@Aspect</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LoggingAspect</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">    </span><span class="nd">@Before</span><span class="p">(</span><span class="s">&#34;execution(* UserService.createUser(..))&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">logBefore</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;准备创建用户...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="9-spring拦截链的实现">9. Spring拦截链的实现<a hidden class="anchor" aria-hidden="true" href="#9-spring拦截链的实现">#</a></h3>
<p>责任链模式，指一系列拦截器依次生效</p>
<ul>
<li>HandlerInterceptor（MVC拦截器）：用于拦截HTTP请求</li>
<li>Filter（过滤器）：基于Servlet API的过滤器</li>
<li>AOP拦截链（切面）：实现方法的前后处理。@Before @After @Around</li>
</ul>
<p>💡在Spring AOP中，@before和@after注解都对应一个Interceptor拦截器，</p>
<p><img alt="image-20250415205311425" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415205311425.png"></p>
<p>责任链模式</p>
<h3 id="10-spring-mvc知识点">10. Spring MVC知识点<a hidden class="anchor" aria-hidden="true" href="#10-spring-mvc知识点">#</a></h3>
<p>基于经典的MVC模式 (Model-View-Controller)来开发Web应用的模块。</p>
<p>基于Servlet API构建，核心是<code>DispatcherServlet</code>, 即请求分发器，将HTTP请求映射到控制器方法中，并将数据返回给视图层进行渲染</p>
<p>Model：业务模型和数据模型 分别是Servie、Repository；</p>
<p>Controller：分别是DispatcherServlet和Controller；(分发&amp;处理)</p>
<p><strong>主要功能：</strong> 请求映射、数据绑定、视图解析、表单处理、异常处理等。</p>
<p>工作流程：</p>
<ul>
<li>HTTP请求 =&gt; DispatcherServlet 根据URL进行分发
<ul>
<li>HandlerMapping：缓存URL到具体处理器对象的映射关系</li>
<li>HandlerAdapter：DispatcherServlet通过该适配器间接调用Handler</li>
</ul>
</li>
<li>URL =&gt; Controller 接收请求并进行业务处理</li>
<li>ModelAndView：数据封装到模型对象中。</li>
<li>ViewResolver:负责呈现数据，前后端分离，不需要这个。</li>
</ul>
<h3 id="11-spring-mvc的具体工作原理">11. Spring MVC的具体工作原理<a hidden class="anchor" aria-hidden="true" href="#11-spring-mvc的具体工作原理">#</a></h3>
<p><img alt="image-20250415210418513" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415210418513.png"></p>
<ul>
<li>
<p>DispatcherServlet接收请求</p>
</li>
<li>
<p>请求映射：根据请求URL查询HandlerMapping，返回Handler执行链(拦截器和处理器)</p>
</li>
<li>
<p>依次执行拦截器preHandle()xN=&gt;Controller，若中断则直接转到afterComplete()</p>
</li>
<li>
<p>获取HandlerAdapter：通过HandlerAdapter执行handle方法，解决不同处理器的差异</p>
</li>
<li>
<p>拦截器postHandle()</p>
</li>
<li>
<p>AfterCompletion()</p>
</li>
<li>
<p>返回响应数据</p>
</li>
</ul>
<h3 id="12-spring中的设计模式">12. Spring中的设计模式<a hidden class="anchor" aria-hidden="true" href="#12-spring中的设计模式">#</a></h3>
<p>工厂模式：BeanFactory</p>
<p>模板方法：RestTemplate、JDBCTemplate，RedisStringTemplate</p>
<p>代理模式：AOP</p>
<p>单例模式：IOC下的Bean</p>
<p>责任链模式：SpringMVC拦截器</p>
<p>观察者模式：Spring中的监听器</p>
<p>适配器模式：handlerAdapter</p>
<h3 id="13-spring中的事务传播行为">13 Spring中的事务传播行为<a hidden class="anchor" aria-hidden="true" href="#13-spring中的事务传播行为">#</a></h3>
<p>父事务与子事务之间的关系？一个事务被另一个事务调用</p>
<p>作用：定义和管理事务边界，定义多个事务方法嵌套时，是否开启新事务、复用事务还是挂起事务。。。</p>
<ul>
<li>Propagation_Required 必须传播
<ul>
<li>最常用的事务传播行为，如果存在事务，执行的方法会<strong>加入</strong>到该事务中，若不存在，则会<strong>创建</strong>一个新事务；</li>
<li>例如下单场景，扣减库存、生产订单记录、更新用户积分等多个操作，应该在一个事务中，以保证数据的一致性</li>
</ul>
</li>
<li>Propagation_SUPPORTS 支持的传播行为
<ul>
<li>当前存在事务则加入，否则非事务方式执行</li>
<li>例如电商场景下，用户查看商品评论列表，这是正常操作。但是在一个事务中调用该方法(进行商品推广活动统计时，同时查看商品评论列表)，则可以加入该事务。</li>
</ul>
</li>
<li>Propagation_MANDATORY 强制的传播行为
<ul>
<li>必须要求存在当前事务，否则抛出异常</li>
<li>场景：促销活动中，进行优惠计算并更新订单金额和扣减库存时，必须在同一个事务中。因为这两是紧密关联的。</li>
</ul>
</li>
<li>Propagation_REQUIRES_NEW 需要新事务的传播行为
<ul>
<li>无论是否存在事务，调用的子方法都会创建一个新的事务。</li>
<li>独立小团体</li>
<li>例子：业务操作和日志操作，这俩相对独立的操作，即使业务失败，日志也应该成功</li>
</ul>
</li>
<li>Propagation_NOT_SUPPORTED  不支持事务的传播行为
<ul>
<li>子方法以非事务的方式执行，若存在事务，先挂起</li>
<li>场景：xxx</li>
</ul>
</li>
<li>Propagation_NERVER 不允许事务的传播
<ul>
<li>要求当前绝对不能存在事务，否则抛出异常</li>
<li>例如: 计算商品的推荐指数时，不涉及事务操作</li>
</ul>
</li>
<li>Propagation_NESTED 嵌套传播行为
<ul>
<li>若当前存在事务，方法将在嵌套事务中执行，否则创建新事务</li>
<li>例子：多个步骤，检查库存，生成订单，发送通知等。生成订单时异常，仅回滚这个子事务，不影响前面的检查库存操作。</li>
</ul>
</li>
</ul>
<h3 id="14-spring-ioc容器初始化过程">14. Spring IOC容器初始化过程<a hidden class="anchor" aria-hidden="true" href="#14-spring-ioc容器初始化过程">#</a></h3>
<p>四阶段</p>
<ul>
<li>启动阶段
<ul>
<li>配置加载：加载配置文件or配置类，XML配置文件、JAVA配置类或配置注解</li>
<li>创建容器：Spring创建IOC容器(BeanFactory\ApplicationContext), 加载和管理Bean</li>
</ul>
</li>
<li>Bean定义和注册阶段
<ul>
<li>解析Bean定义，注册到容器中</li>
</ul>
</li>
<li>实例化和依赖注入
<ul>
<li>实例化：根据BeanDefinition创建Bean实例</li>
<li>依赖注入：根据构造函数、Setter方法、字段注入，将依赖注入到Bean中</li>
</ul>
</li>
<li>初始化
<ul>
<li>BeanPostProcessor：处理器会在Bean初始化完成后执行</li>
<li>@Post Construct Bean的初始化方法</li>
</ul>
</li>
</ul>
<p><img alt="image-20250415213456343" loading="lazy" src="c:\\Users\\韦龙\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250415213456343.png"></p>
<h3 id="15-qualifier注解">15 Qualifier注解<a hidden class="anchor" aria-hidden="true" href="#15-qualifier注解">#</a></h3>
<p>例如：当多个接口有多个实现时，指定哪个具体的Bean，<strong>消除歧义</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Client</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="n">service</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Client</span><span class="p">(</span><span class="nd">@Qualifier</span><span class="p">(</span><span class="s">&#34;serviceImpl1&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="n">service</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">service</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">service</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">        </span><span class="n">service</span><span class="p">.</span><span class="na">serve</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>@Primary</strong> 多个Bean实现了继承了某个类，依赖注入优先为带有@Primary的类</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nd">@Primary</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DefaultService</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">serve</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Default Service&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w"></span><span class="nd">@Qualifier</span><span class="p">(</span><span class="s">&#34;specificService&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SpecificService</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">serve</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Specific Service&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Client</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="n">service</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Client</span><span class="p">(</span><span class="nd">@Qualifier</span><span class="p">(</span><span class="s">&#34;specificService&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="n">service</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">service</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">service</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">        </span><span class="n">service</span><span class="p">.</span><span class="na">serve</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="16-事务的失效场景">16 事务的失效场景<a hidden class="anchor" aria-hidden="true" href="#16-事务的失效场景">#</a></h3>
<p>使用@Transactional声明式事务时，存在以下事务失效情况</p>
<ul>
<li>
<p>⭐rollbackFor：没设置对，默认为(RuntimeException or Error回滚才生效)，而自定义异常和IOException等并不会回滚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="nd">@Transactional</span><span class="p">(</span><span class="n">rollbackFor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Exception</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>⭐异常被捕获了，异常被catch了，仅打印log，并没有将异常往回抛出。</p>
</li>
<li>
<p>⭐同一个类中方法调用，因为事务是基于动态代理实现的，自己调用自己的方法不会走代理方法</p>
<ul>
<li>只有通过代理对象调用的方法才会被事务拦截器增强</li>
<li>当类内部方法A调用方法B时，实际上是<code>this.methodB()</code>调用，而不是<code>proxy.methodB()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">((</span><span class="n">XXXService</span><span class="p">)</span><span class="n">AopContext</span><span class="p">.</span><span class="na">currentProxy</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">applyMethod</span><span class="p">(</span><span class="n">xxx</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>@Transactional应用在<strong>非public</strong>修饰上，Spring事务判断非公开方法不执行事务</p>
</li>
<li>
<p>⭐事务传播设置不当，设置为Requires_new，会创建子事务，两个无关</p>
</li>
<li>
<p>多线程环境，@Transactional基于ThreadLocal，因此多线程不能保持事务同步。</p>
</li>
</ul>
<h3 id="17-spring-启动过程">17. Spring 启动过程<a hidden class="anchor" aria-hidden="true" href="#17-spring-启动过程">#</a></h3>
<ul>
<li><strong>创建&lt;容器&gt;</strong>：
<ul>
<li>根据配置文件中的信息创建容器 ApplicationContext，容器启动阶段实例化BeanFactory，并加载容器总的BeanDefinitions</li>
</ul>
</li>
<li><strong>加载&lt;配置&gt;</strong>：
<ul>
<li>读取XML配置文件，JAVA Config类，和基于注解的Bean，包括数据库连接配置、AOP配置等等。</li>
</ul>
</li>
<li><strong>注册Bean&lt;定义&gt;</strong>
<ul>
<li>解析配置文件中定义的BeanDefinition和声明的Bean元数据</li>
</ul>
</li>
<li>**&lt;实例化&gt;**Bean：实例化Bean对象，并放入容器中进行管理</li>
<li><strong>&lt;注入依赖&gt;</strong>：
<ul>
<li>注入Bean对象中的依赖对象，构造器，setter，字段注入</li>
</ul>
</li>
<li><strong>&lt;初始化&gt;Bean</strong>
<ul>
<li>InitializingBean，or afterPropertiesSet ? 这是什么呢 &amp; BeanPostProcessors</li>
</ul>
</li>
</ul>
<hr>
<h3 id="18-value注解">18. @Value注解<a hidden class="anchor" aria-hidden="true" href="#18-value注解">#</a></h3>
<p>注入外部资源的<strong>值</strong></p>
<ul>
<li>配置文件注入</li>
</ul>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-properties" data-lang="properties"><span class="line"><span class="ln">1</span><span class="cl"><span class="na">app.name</span><span class="o">=</span><span class="s">MyApp</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="na">app.version</span><span class="o">=</span><span class="s">1.0.0</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">org.springframework.stereotype.Component</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AppConfig</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="nd">@Value</span><span class="p">(</span><span class="s">&#34;${app.name}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">appName</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">    </span><span class="nd">@Value</span><span class="p">(</span><span class="s">&#34;${app.version}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">appVersion</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">getAppName</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">appName</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">getAppVersion</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">appVersion</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">    
</span></span></span></code></pre></div><h3 id="19-常用的注解">19 常用的注解<a hidden class="anchor" aria-hidden="true" href="#19-常用的注解">#</a></h3>
<ul>
<li>
<p>@PostConstruct：Bean初始化完成后调用</p>
<ul>
<li>提前加载数据</li>
</ul>
</li>
<li>
<p>@PreDestory： Bean销毁前调用</p>
<ul>
<li>关闭连接，释放资源</li>
</ul>
</li>
<li>
<p>@Scheduled 定时任务</p>
</li>
<li>
<p>@Conditional 有条件的装配Bean对象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="nd">@Conditional</span><span class="p">(</span><span class="n">OnLinuxCondition</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">  </span><span class="c1">// 仅这个类存在时才装配这个Bean到容器中</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">MyService</span><span class="w"> </span><span class="nf">myService</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyService</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>@ControllerAdvice 全局异常处理</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="nd">@ControllerAdvice</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">    </span><span class="nd">@ExceptionHandler</span><span class="p">(</span><span class="n">Exception</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">ResponseEntity</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">handleAllExceptions</span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ResponseEntity</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="s">&#34;An error occurred: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="na">getMessage</span><span class="p">(),</span><span class="w"> </span><span class="n">HttpStatus</span><span class="p">.</span><span class="na">INTERNAL_SERVER_ERROR</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://longcoding.top/tags/spring/">Spring</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://longcoding.top/posts/jobs/redis/">
    <span class="title">« Prev</span>
    <br>
    <span>Redis面试题笔记</span>
  </a>
  <a class="next" href="http://longcoding.top/posts/jobs/java/">
    <span class="title">Next »</span>
    <br>
    <span>Java面试题笔记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://longcoding.top/">LongCoding&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
