<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL面试题笔记 | LongCoding&#39;s Blog</title>
<meta name="keywords" content="MySQL">
<meta name="description" content="617 MySQL 数据排序 实现？

Order By 命中索引(包括索引字段)，使用索引排序(有序)，效率最高效
否则使用文件排序，文件少=&gt; 内存排序 sort_buffer
文件大=&gt;外部排序，归并排序

内部排序细节：
双路排序(待排序的列数据太大了)：使用row_id(回查表) &#43; sort_field
​		排好序后，使用row_id将完整的记录取出来
单路排序(待排序数据大小能接受)
​	直接拍，不会查表，直接把拍好的结果返回
外部排序：
拆分小的，外部多路归并排序，小=&gt;大
外部归并排序 =&gt; 先分段排序，每一段调入内存执行快排
​                        =&gt; 归并阶段，因为每子段都是有序的 =&gt; 多路归并排序
589 一条SQL的执行过程

先通过连接器校验权限
利用分析器进行SQL语句词法分析和语法分析，构建解析树
利用优化器选择合适的索引和表连接顺序，最终选择一条最佳的执行计划
利用执行器，调用引擎层查询数据，返回结果集

具体：Select * from user where id = 1;



SQL =&gt; Server层连接器，权限校验，账号是否有资格获取。无=&gt; Access denied for user。  连接成功后，空闲一段时间会断开


分析器(查询解析) =&gt;

语法分析：SQL  : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。
语义分析：语法是否有误 =&gt; you have an error in your SQL syntax (字段、表|存在？)   分析解析树语法正确性



优化器(查询优化)=&gt;">
<meta name="author" content="LongWei">
<link rel="canonical" href="http://121.40.252.207/posts/jobs/mysql/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://121.40.252.207/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://121.40.252.207/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://121.40.252.207/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://121.40.252.207/apple-touch-icon.png">
<link rel="mask-icon" href="http://121.40.252.207/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://121.40.252.207/posts/jobs/mysql/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://121.40.252.207/posts/jobs/mysql/">
  <meta property="og:site_name" content="LongCoding&#39;s Blog">
  <meta property="og:title" content="MySQL面试题笔记">
  <meta property="og:description" content="617 MySQL 数据排序 实现？ Order By 命中索引(包括索引字段)，使用索引排序(有序)，效率最高效 否则使用文件排序，文件少=&gt; 内存排序 sort_buffer 文件大=&gt;外部排序，归并排序 内部排序细节：
双路排序(待排序的列数据太大了)：使用row_id(回查表) &#43; sort_field
​	排好序后，使用row_id将完整的记录取出来
单路排序(待排序数据大小能接受)
​	直接拍，不会查表，直接把拍好的结果返回
外部排序：
拆分小的，外部多路归并排序，小=&gt;大
外部归并排序 =&gt; 先分段排序，每一段调入内存执行快排
​ =&gt; 归并阶段，因为每子段都是有序的 =&gt; 多路归并排序
589 一条SQL的执行过程 先通过连接器校验权限 利用分析器进行SQL语句词法分析和语法分析，构建解析树 利用优化器选择合适的索引和表连接顺序，最终选择一条最佳的执行计划 利用执行器，调用引擎层查询数据，返回结果集 具体：Select * from user where id = 1;
SQL =&gt; Server层连接器，权限校验，账号是否有资格获取。无=&gt; Access denied for user。 连接成功后，空闲一段时间会断开
分析器(查询解析) =&gt;
语法分析：SQL : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。 语义分析：语法是否有误 =&gt; you have an error in your SQL syntax (字段、表|存在？) 分析解析树语法正确性 优化器(查询优化)=&gt;">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-04T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-04T00:00:00+00:00">
    <meta property="article:tag" content="MySQL">
      <meta property="og:see_also" content="http://121.40.252.207/posts/jobs/collection/">
      <meta property="og:see_also" content="http://121.40.252.207/posts/jobs/jvm/">
      <meta property="og:see_also" content="http://121.40.252.207/posts/jobs/juc/">
      <meta property="og:see_also" content="http://121.40.252.207/posts/jobs/redis/">
      <meta property="og:see_also" content="http://121.40.252.207/posts/jobs/java/">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL面试题笔记">
<meta name="twitter:description" content="617 MySQL 数据排序 实现？

Order By 命中索引(包括索引字段)，使用索引排序(有序)，效率最高效
否则使用文件排序，文件少=&gt; 内存排序 sort_buffer
文件大=&gt;外部排序，归并排序

内部排序细节：
双路排序(待排序的列数据太大了)：使用row_id(回查表) &#43; sort_field
​		排好序后，使用row_id将完整的记录取出来
单路排序(待排序数据大小能接受)
​	直接拍，不会查表，直接把拍好的结果返回
外部排序：
拆分小的，外部多路归并排序，小=&gt;大
外部归并排序 =&gt; 先分段排序，每一段调入内存执行快排
​                        =&gt; 归并阶段，因为每子段都是有序的 =&gt; 多路归并排序
589 一条SQL的执行过程

先通过连接器校验权限
利用分析器进行SQL语句词法分析和语法分析，构建解析树
利用优化器选择合适的索引和表连接顺序，最终选择一条最佳的执行计划
利用执行器，调用引擎层查询数据，返回结果集

具体：Select * from user where id = 1;



SQL =&gt; Server层连接器，权限校验，账号是否有资格获取。无=&gt; Access denied for user。  连接成功后，空闲一段时间会断开


分析器(查询解析) =&gt;

语法分析：SQL  : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。
语义分析：语法是否有误 =&gt; you have an error in your SQL syntax (字段、表|存在？)   分析解析树语法正确性



优化器(查询优化)=&gt;">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://121.40.252.207/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MySQL面试题笔记",
      "item": "http://121.40.252.207/posts/jobs/mysql/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL面试题笔记",
  "name": "MySQL面试题笔记",
  "description": "617 MySQL 数据排序 实现？ Order By 命中索引(包括索引字段)，使用索引排序(有序)，效率最高效 否则使用文件排序，文件少=\u0026gt; 内存排序 sort_buffer 文件大=\u0026gt;外部排序，归并排序 内部排序细节：\n双路排序(待排序的列数据太大了)：使用row_id(回查表) + sort_field\n​\t排好序后，使用row_id将完整的记录取出来\n单路排序(待排序数据大小能接受)\n​\t直接拍，不会查表，直接把拍好的结果返回\n外部排序：\n拆分小的，外部多路归并排序，小=\u0026gt;大\n外部归并排序 =\u0026gt; 先分段排序，每一段调入内存执行快排\n​ =\u0026gt; 归并阶段，因为每子段都是有序的 =\u0026gt; 多路归并排序\n589 一条SQL的执行过程 先通过连接器校验权限 利用分析器进行SQL语句词法分析和语法分析，构建解析树 利用优化器选择合适的索引和表连接顺序，最终选择一条最佳的执行计划 利用执行器，调用引擎层查询数据，返回结果集 具体：Select * from user where id = 1;\nSQL =\u0026gt; Server层连接器，权限校验，账号是否有资格获取。无=\u0026gt; Access denied for user。 连接成功后，空闲一段时间会断开\n分析器(查询解析) =\u0026gt;\n语法分析：SQL : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。 语义分析：语法是否有误 =\u0026gt; you have an error in your SQL syntax (字段、表|存在？) 分析解析树语法正确性 优化器(查询优化)=\u0026gt;\n",
  "keywords": [
    "MySQL"
  ],
  "articleBody": "617 MySQL 数据排序 实现？ Order By 命中索引(包括索引字段)，使用索引排序(有序)，效率最高效 否则使用文件排序，文件少=\u003e 内存排序 sort_buffer 文件大=\u003e外部排序，归并排序 内部排序细节：\n双路排序(待排序的列数据太大了)：使用row_id(回查表) + sort_field\n​\t排好序后，使用row_id将完整的记录取出来\n单路排序(待排序数据大小能接受)\n​\t直接拍，不会查表，直接把拍好的结果返回\n外部排序：\n拆分小的，外部多路归并排序，小=\u003e大\n外部归并排序 =\u003e 先分段排序，每一段调入内存执行快排\n​ =\u003e 归并阶段，因为每子段都是有序的 =\u003e 多路归并排序\n589 一条SQL的执行过程 先通过连接器校验权限 利用分析器进行SQL语句词法分析和语法分析，构建解析树 利用优化器选择合适的索引和表连接顺序，最终选择一条最佳的执行计划 利用执行器，调用引擎层查询数据，返回结果集 具体：Select * from user where id = 1;\nSQL =\u003e Server层连接器，权限校验，账号是否有资格获取。无=\u003e Access denied for user。 连接成功后，空闲一段时间会断开\n分析器(查询解析) =\u003e\n语法分析：SQL : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。 语义分析：语法是否有误 =\u003e you have an error in your SQL syntax (字段、表|存在？) 分析解析树语法正确性 优化器(查询优化)=\u003e\n优化SQL，比如：选择哪个索引、调整多个表的连接顺序 执行器（查询执行）\n校验用户对表的权限，根据存储引擎查询数据，遍历 =\u003e 返回结果集\n590 MySQL 存储引擎 InnoDB\n提供事务、行级锁和外键\n提供高并发性能\nB+树索引\nMVCC\n591 MySQL的索引类型有哪些 数据结构角度：\nB+树索引： 通过树型结构 =\u003e 适合范围查询between和精确查=。 叶子节点双向链表连接 比B树具备更少的IO次数 InnoDB+树索引结构上看\n聚簇索引(主键构建)： 非叶子节点存储索引值 叶子节点存储完整的数据行数据，可以直接访问完整数据 每个表只能有一个聚簇索引 非聚簇索引 (二级索引) 非叶子节点存储索引值 叶子节点存储主键和对应索引列，查询非对应索引列，则需要回表(根据主键)，增加额外的IO（SELELCT * 慎重） 索引:\n主键索引\n唯一索引\n普通索引\n单列索引 \u0026 联合索引\n1主键： 2PRIMARY Key(id) 3唯一： 4Create unique index xxx on user(username); 5联合： 6Create INdex xxx on user(username, email); MySQL索引的最左前缀匹配原则？ 针对联合索引\n联合索引在B+树种的排列方式遵循“从左到右”的顺序 e.g. (first_name, last_name, age) 会按照 这个顺序进行索引\n1 (Alice, Black, 35) 2 | 3 ------------------------------------------------------------- 4 | | | | 5(Alice, Brown, 25) (Alice, Smith, 30) (Bob, Smith, 20) (Bob, White, 19) 查询时候WHERE 条件顺序最好和索引一致，否则跳过最左侧会导致无法利用该索引\n=\u003e 要保证索引命中，建议索引顺序一致\n不能跳过第一个索引\n可以部分匹配但第一个一定要在\nindex: (a, b, c)\n1where a=1 ✔️ 2where a=1 and b=1 ✔️ 3where a=1 and b=1 and c=1✔️ 4 5where b=1 and a=1 ❌❌❌ 595 MySQL索引覆盖 指二级索引包含了查询所需的所有字段 - 一级索引(Primary key，唯一) ˈpraɪməri - 二级索引(其他索引)\n1# INDEX idx_name_hiredate (last_name, first_name, hire_date) 2 3SELECT ... 4WHERE last_name = ? AND first_name = ? 5 6则不需要回表查询，因为这个SQL会根据联合索引进行查询，并且查询的条件列包含所需的数据 596 MySQL索引下推 应用在联合索引上，减少回表查询。MySQL自动应用的优化技术\n主要是将条件索引列的过滤操作下推到存储引擎层，减少不必要的数据传输\n通过二级索引查到主键id后回表再进行where条件过滤\n=\u003e 二级索引查到数据后直接where条件过滤一遍，再进行回表查询，减少回表的次数\n1# example 联合索引：index_age_grade 2(1, 'Alice', 18, 90), 3(2, 'Bob', 19, 85), 4(3, 'Charlie', 18, 95), 5(4, 'David', 20, 80); 6=\u003e SELECT ... WHERE age = 18 and grade \u003e 90 7# 没有索引下推： 81. 先根据age查找到所有结果 92. 返回所有结果数据到服务器层 103. 服务器层过滤grade\u003e90的数据 11 12# 索引下推 131. 先根据age查找到所有结果 142. 存储引擎层直接过滤grade\u003e90的数据 153. 返回数据给服务器层 597 建立索引注意事项 不能盲目建立，因为维护需要代价 表的修改频率远大于查询频率 =\u003e 维护代价大 598 排查索引效果？ 在SQL语句前，使用EXPLAIN关键字，查看SQL语句的执行信息\n联合索引 =\u003e 符合最左前缀顺序 索引中使用运算或者函数，like进行全盘扫描，对值进行了处理，则会使索引失效 破坏最左匹配 in字段 order by 为使用索引 600 MySQL的B+树查询数据的全过程 查询从跟节点出发，比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定往下哪个分支走，从上到下定位到叶子节点 叶子节点存储着数据行记录，但一页的大小有16kb，存储的数据行不只一条 叶子节点中的数据行以组的形式划分，利用页目录结构，通过二分查找定位到对应的组 定位到组后，利用链表遍历=\u003erow 601 为什么使用B+树作为索引结构 高效的查询性能 自平衡，根到叶子路径长度相同 O(logn) 树高长的不会过快，使得查询磁盘的IO次数减少 非叶子节点只存放索引值和页面指针 每一页中能够容纳更多的记录，减少查询的IO次数 范围查询能力强 叶子节点通过链表连接，定位到叶子节点，根据范围查询只需要顺序扫描链表 B树\n每个节点都存储了完整的数据 B树叶子节点没有连接指针 602 MySQL怎么实现事务 ❌❌❌ 通过锁、Redo Log、Undo Log、 MVCC实现事务\n利用锁(行锁、间隙锁等)机制，控制数据的并发修改，满足事务的隔离性\nRedo Log(重做日志)，它记录事务对数据库的修改，当MySQL宕机了，通过重放redo log可以恢复数据，满足事务的持久性\nUndo Log(回滚日志)，记录事务的反向操作，保持数据的历史版本，用于事务的回滚，使事务执行失败后可以恢复到之前的样子。实现原子性和隔离性\nMVCC 多版本并发控制，满足非锁读的需求，提供读写并发，实现了读已提交和可重复读两种隔离级别\n读已提交：每次查询生成新的 ReadView，可能导致多次查询结果不一致 可重复读：事务启动时生成 ReadView，保证整个事务中查询结果一致 事务工作流程：\nRedo Log(重做日志)：\n=\u003e 保证事务的持久性，即使宕机了也能恢复提交的数据\n版本链示意\n​\n609 Mysql有哪些锁 粒度分类：\n全局锁：整个数据库加锁，只读\n行级锁：细粒度\n对特定的行加锁，允许其他事务并发访问不同的行，适用于高并发的场景 表级锁 粗粒度\n对整个表进行加锁，其他事务无法对该表进行操作 属性分类：\n共享锁 S锁 Shared lock\n允许多个事务并发读同一资源，但是不允许修改，只有释放共享锁后，其他事务才能获取排他锁 排他锁 Exclusive lock X锁\n只允许一个事务读写资源，互斥，独享 1-- 添加共享锁 2SELECT ... LOCK IN SHARE MODE; 3-- 共享锁 4SELECT ... FOR SHARE; 5-- 排他锁 6SELECT ... FOR UPDATE; 记录锁：锁定特定的行记录\n间隙锁\n针对索引中两个记录之间的间隙加锁，防止其他事务在这个间隙中插入新的数据，避免幻读。锁定行与行之间的空间 阻止新的记录的插入 临键锁\n锁定具体行和其前面的间隙，确保范围内不会幻读 603 MySQL长时间事务可能造成什么问题？ 问题：\n长时间事务 =\u003e 长时间的锁竞争+阻塞资源 其他事务也需要对应的锁，但是这个锁长时间拿不到，阻塞 部分业务的阻塞会影响到其他服务，导致系统出现严重的服务崩盘 死锁风险 多个事务相互等待对方释放锁，导致系统无法继续执行 回滚导致时间的浪费 执行了很长，但是快结束出现异常 =\u003e 事务回滚需要很长的时间 长时间事务如何解决\n拆分成一小份一小份的短事务\n时间？ 创造索引条件，得到表的主键最大值和最小值，切分成一小份一小份的区间在执行\n删除大量的数据 =\u003e 在新的表中插入相对小的数据\n604 MVCC [数据版本控制隐藏字段和指针、事务视图ReadView]\nMulti-Version Concurrency Control 多版本并发控制 =\u003e 允许事务同时读写数据库，而无需相互等待\n提高并发性能 \u0026 避免读写冲突 \u0026 减少锁竞争 MVCC中，为每个事务创建一个数据快照，当数据被修改时，MySQL不会立即覆盖原有数据，而是生成新版本的记录。每个记录都保留着相应的版本号\n读写冲突：传统读写或互斥。解决方法：多版本方式，读旧版本数据，写在新版本上，从而避免读写冲突。 锁竞争：传统方式需要竞争锁，解决方式：通过版本控制替代锁。 事务隔离级别实现：传统机制：锁。解决方式：版本控制。 MVCC为每条数据维护多个版本\n每个版本包括：\n版本号：标识创建版本的事务ID 时间戳：创建时间 数据内容 读操作：\n根据事务的隔离级别和当前时间戳，选择合适的数据版本。\n在读已提交下隔离级别下：读操作会读取已提交的最新版本 在可重复读隔离级别下：读操作会读取事务开始时的数据版本 写操作:\n=\u003e 创建新的数据新版本，而不是修改旧版本数据 旧版本数据会被保留，直到没有任何事务引用 \u003c= 垃圾回收 MVCC优势：\n高并发； 灵活的隔离级别； 减少锁竞争； 一致性视图 隐藏字段：\n每行记录除了自己定义的字段外，还有一些重要的隐藏字段\ndb_row_id： 没有定义Primary Key，默认用这个为Index db_trx_id：最近对这个记录修改的事务ID db_roll_ptr: 回滚指针，指向这个记录的上一个版本，指向Undo Log中的上一个快照版本的地址 多版本之间串联起来形成一条版本链。 不同事务可以无锁的读取不同版本的数据(普通读)。普通读和写不会阻塞\n写操作可以继续写，就是新的数据版本不会立即对其他事务可见，只有事务提交后，新版本的记录才会可见\nMySQL InnoDB通过Undo Log 操作 和 ReadView实现\nUndo Log 记录数据修改之前的状态的日志，作用如下：\n事务回滚：撤销未提交的事务修改 实现MVCC：提供历史版本数据，支持一致性读 =\u003e 当事务修改数据时，InnoDB会将数据的旧版本写入Undo Log中\n=\u003e 当Undo Log没被任务事务引用时，会被垃圾回收\nReadView 读视图\n事务某时刻创建的数据库快照，用于确定哪些数据版本对事务可见 =\u003e 实现事务隔离性\n核心字段\nm_ids: 当前活动事务ID列表 min_trx_id: m_ids中最小事务的ID max_trx_id creator_trx_id: 创建该ReadView事务的ID 可见性规则\n对于每条数据的版本，ReadView会根据一下规则判断是否可见\n当数据版本的事务ID \u003c min_trx_id\n=\u003e 数据版本以及提交(过去的事务)，可见\n当数据版本的事务ID \u003e= max_trx_id\n​\t=\u003e 说明数据版本是未来事务创建的，不可见\n​\t3. 数据版本的事务ID 在 m_ids中 ⭐⭐⭐\n​\t=\u003e 说明他是由未提交的事务创建的， 不可见, 否则可见\n如果当前数据版本的 trx id 大小在 min trx id 和 max trx id 之间，此时 trx id 若在 m ids 中，说明修改这条数据的事务此时还未提交，所以不可见，若不在m ids 中，表明事务已经提交，可见。\r​\t4. 数据版本的事务ID == creator_trx_id\n​\t=\u003e 自己创建的，可重入，当然可见了\n​\t可见性取决于ReadView的快照机制 =\u003e ReadView创建时间 决定了事务能看到哪些已提交的数据。\nMVCC\n解决脏读：事务只能读取已提交的数据记录；可见性控制 =\u003e 去UndoLog中找历史记录\n解决不可重复读：ReadView\n❗不能解决幻读：比当前事务Id小的事务提交了，那么新出现的记录可以被看到，特别是范围查询的时候\n使用场景：\nMVCC：读多写少的场景 =\u003e 商品库存查询？ 读事务不会被写事务阻塞 对于银行金额变更场景 =\u003e 锁 事务隔离级别 事务的ACID特性：Atomicity, Consistency, Isolation, Durability\n数据一致性问题：\n脏读：事务A读取了事务B尚未提交的数据，此时事务B回滚，那么A读的数据是脏数据(无效) 幻读：同一事务中，多次执行的相同查询，得到的结果集不一致。 其他事务插入新的数据并提交 不可重复读：同一事务，多次读取的同一数据，结果不一致 因为事务执行期间，其他事务对结果进行了修改 事务隔离级别：避免上述数据不一致问题\n读未提交：允许事务读取其他事务未提交的数据。 会引起：脏读、幻读、不可重复读； 读已提交：事务只能读取其他事务已提交的数据。避免了：在脏读；(默认) 可重复读：加锁(行锁)，确保事务多次读取同一数据的一致性。避免了：脏读、不可重复读；可能：幻读 串行化：事务完全串行执行：锁定整个表或者范围来实现。避免：脏读、幻读、不可重复读 MySQL主从复制 核心是基于二进制日志(BinLog File)进行数据同步\n主库(Master)记录变更 任何对数据库进行变更的操作都会被记录到BinLog中。Update Delete Insert 从库Slave获取Binlog 从库通过IO线程连接主库，读取Binlog，并存入本地中继日志中(Relay log) 从库Slave 回放Binlog 从库SQL线程解析Relay Log，执行相同的SQL语句，进而保持与主库相同的数据 一主多从\n一个主库，多个从库，每个从库独立同步主库数据 主从复制的优势\n数据冗余 =\u003e 更安全 读写分离 =\u003e 主库写，从库读，提高性能 高可用性 =\u003e 主库故障 切换从库，提高系统可靠性 610 MySQL乐观锁\u0026悲观锁 乐观锁：比如CAS机制，不加锁实现并发。并发性能高。 比较版本号和时间戳实现\n悲观锁：每次操作都加锁，互斥操作，数据一致性要求高的场景。并发性能低\n​\n616 MySQL SQL调优 通过分析慢SQL，利用explain分析查询语句的执行计划，识别性能瓶颈，优化查询语句\n合理设计索引，利用联合索引进行覆盖索引的优化\n覆盖索引：让常用的字段都在索引中，这样就可以减少回表查询的开销 索引下层：过滤掉不符合查询条件的数据，减少回表操作 自动的 避免 SELECT *，只查询必要的字段\n避免在SQLWHRER中执行函数计算，使得索引失效\n避免%LIKE，导致全屏扫描\n注意联合索引需满足最左匹配原则\n不要对无索引字段进行排序\n通过业务的优化，进行缓存，减少对数据库的访问\n减少多表查询的情况\nJOIN操作，数据量大时，容易导致查询速度慢，影响数据库性能 避免频繁使用JOIN多张大表，而是分步查询或缓存 必要时使用冗余存储，减少JOIN。 一次查大量数据的优化方式\n分页查询\n使用LIMIT和OFFSET，每次只查一部分数据\n1SELECT ... FROM ... WHERE ... LIMIT ??? OFFSET ... 分批次查询：\n```sql\rSELECT ... FROM ... WHERE id \u003e 1000 ORDER BY id LIMIT 100;\r```\r回答：索引相关：\n查询的时候，满足最左前缀匹配原则 最小查询，只查询所需要的必要信息。减少回表情况 利用好索引，加速检索。 避免全盘扫描的情况 避免 Like % 全盘匹配 避免WHere中对字段进行函数操作，使得索引失效 不要对无关字段进行排序 利用好缓存，直接减少数据库的访问 619 MySQL实现读写分离 读操作次数远大于写操作\n将读操作分摊到从数据库中。主数据库负责写操作。然后通过主从复制，同步数据。\n数据一致性要求高的场景\n⭐1. 关键事务必须强制从主库中读取数据\n支付订单状态 扣减库存等等 2.半同步控制\n当事务提交后，至少有一个从库确认接收到数据，才认为数据写入成功\n3.业务层解决，将数据写入Redis中，优先从缓存中读取数据\n读写分离 =\u003e 将压力分摊到子库中，提高性能\n同步 =\u003e 数据一致性 =\u003e 全同步， 半同步 620 MySQL主从复制机制 应用场景数据备份or主从数据同步\n同步复制：将binlog file复制到所有从库，等所有从库响应了，主库才响应客户端 （性能差，数据一致性高） 半同步复制：主库等待至少一个从库确认收到数据（性能折中，数据一致性较高） 异步复制：主库不用等待从库确认（性能高，数据一致性差） 如何实现同步过程\n提交事务请求 =\u003e 主库 =\u003e 同时写入binlog file，更新数据并相应客户端，并推送binlog更新事件 binlog file 被主库的dump线程发送给从库 从库IO线程接收binlog，并写入Relay log(中继日志)中，缓冲 从库SQL线程从Relay log重写事件到从库数据库中。 622 数据库进行分库分表以及带有的问题 分库分表策略\n**水平分表：**将一张表的数据，放在两个表中。例如根据ID **垂直分表：**将一张表不同列拆分到多个表中，⭐减少每张表的字段数提高查询效率。例如，用户表可以拆分为基本信息和详细信息表。 **水平分库：**将相同表结构复制一份到另一张表中，减少单一数据库的读写压力。 **垂直分库：**根据业务功能，将表分到不同数据库中。例如将用户数据、商品数据分别存储到不同的数据库中。 为什么需要分库分表？\n随着用户越来越多，导致表数据量大(数据堆积)，读写请求多(并发量高)。\n=\u003e导致 性能瓶颈，单一数据库性能有限。\n分表：100w中找，和1w中找还是不一样的。可以先hash计算到底在哪个数据库，再具体执行。 分库：可以按业务or功能不同，将请求分配到多态服务器上，降低单一服务器压力。 624 数据库分库分表可能引发的问题 单机 =\u003e 分布式\n事务问题：会出现事务的数据不一致问题，需要使用分布式事务解决。 JOIN连表问题： 跨服务器无法JOIN表，业务中实现关联，或者使用冗余字段。 **全局唯一ID问题：**单机，使用自增长的ID即可，分布式必须使用全局唯一ID发号器生成唯一ID。 **排序问题：**上推到业务中实现。 **count问题：**业务代码中累加。 625 MySQL获取数据，从磁盘中写的吗？ MySQL中，并不总是从磁盘中读取。利用缓存机制，提高读取性能。\nmysql8.0中有查询缓存，只有sql相同时才会命中，命中率低，在8.0后移除了\nbuffer pool(old sublist, young sublist), 里面存储了一个一个的数据页，mysql会从buffer pool中找，找到就返回。\n=\u003e 一块内存空间，访问某个数据(磁盘中)时，会将包括该数据的页加载到内存中。页大小16KB，局部性原理，以后对该页的修改和访问都在buffer pool中进行。\n=\u003e 内存淘汰策略：变体的LRU(least recently used最近最少使用)。 buffer pool将数据分为年轻代和老年代(默认5:3)，当数据从磁盘调到内存中时，因为空间时间局部性，新的数据会放在老年队列中，当1s中没有再次访问时才转到年轻队列中。\n=\u003e 如果直接放在年轻代中，可能会把热点数据淘汰掉\n=\u003e 1s，时间窗口，渡过这个时间还被访问认为是热点数据。\n629 为什么不推荐多表JOIN 数据量大的时候，多表JOIN，数据库需要对联接的每个表进行扫描，会消耗大量的CPU和内存资源。 性能比较低\n数据库往往是我们系统的弱点，很多情况性能瓶颈都在数据库，因此我们需要尽可能避免把压力放在数据库上。\nJOIN连接表的时候，需要关注被驱动表的查询是否能够命中索引，不然会导致全表扫描。\n尽可能让小表做驱动表，因为驱动表需要全表扫描，而被驱动表是通过索引查询的。且被驱动表最好能够命中索引。\n例子\n1SELECT * FROM ... a1 join ... a2 on (a1.a == a2.a) 小表有A行，大表有B行。每次扫描A，每行都需要去大表里面查，时间LogB(命中索引)，假设存在回表，那么为2*LogB的查询时间。有A行，那么查B表的时间为=\u003eA*2*LogB；查A表的时间为A,total =\u003e A+A*2*LogB。\nJOIN SQL查询的流程\n扫描A表(小表) 读取A表的所有行，及A次操作 查询B表 A行 * LogB(命中索引的查询时间) * 2(回表时间) =\u003e A + A*2*LogB 630 MySQL中解决深度分页问题 深度分页是指数据量很大的时候，按照分页访问后面的数据，例如limit 99999, 10，这回使得数据库扫描前面的99999条数据，才能得到最终的10条数据。\n1LIMIT num1, num2; -- 偏移量， 返回行数。 会扫描起点到num1整段记录 2LIMIT num1; -- 返回行数 解决方法：\n子查询： 子查询 + 记录上一次查询的 Last ID 1SELECT id, name 2FROM tabel 3WHERE name = 'A' 4and id \u003e= (SELECT id FROM tabel WHERE name = 'A' order by id limit 99999, 1) 5order by id limit 10; 6 7-- 传递上一次查询的最后一个ID 8SELECT * FROM users WHERE id \u003e last_id ORDER BY id LIMIT 10; 1418 数据库视图 数据库视图是虚拟表，作用：简化复杂查询、安全性、数据抽象、可重用性\n1CREATE VIEW employee_salaries AS 2SELECT 3 e.employee_id, 4 CONCAT(e.first_name, ' ', e.last_name) AS full_name, 5 d.department_name, 6 e.salary 7FROM 8 employees e 9JOIN 10 departments d ON e.department_id = d.department_id; 11 12-- CREATE VIEW view__ AS 1479 什么情况下，不推荐为数据库建立索引 有以下几种情况：\n原因 数据量小的表 建议索引并不会显著提高查询性能，反而增加复杂性 频繁更新的表 每个插入删除操作，都需要更新索引，导致过高的维护索引的开销 高度重复的列 例如，性别，索引效果不明显，反而增加存储空间 长文本字段 这些类型的列包含大量数据，添加索引，导致无法使用内存排序，需要利用磁盘，导致大量IO 3179 数据库不停服迁移 通过数据双写实现\n**旧数据同步：**采用主从同步方式，将新库作为旧库的从库，实现历史数据的迁移； **新数据同步：**采用数据双写方式，将新数据同时写入新旧两个库中。 **一致性检查：**定时任务，抽检两个库的数据一致性； 灰度切流： 逐渐将用户的数据请求，迁移到新库中。 4040 MySQL数据库的性能优化方法 SQL 和 库表两部分设计，优化MySQL性能问题。\nSQL优化:\n避免 SELECT * ，只查询必要字段； 避免在SQL中进行函数等计算操作，导致索引失效； 避免使用 %Like，导致全表扫描； 注意联合索引需要满足最左匹配原则； 不要对无索引字段进行排序。 库表设计\n合理表结构：合理的数据类型； 合理冗余字段：冗余设计，减少关联查询； 索引优化：根据查询频率和条件，创建合适的索引； 分库分表：提高读写性能。 1219 数据库三大范式 第一范式：原子性，字段只包含单一数据项；\n第二范式：非主键必须依赖于整个主键；\n第三范式：非主键字段只依赖于主键，不应该相互依赖。\n数据库中存储金额数据使用的数据类型：bigint and decimal\nsql:java\nbigint: long;\ndecimal:BigDecimal\n1482 MySQL中EXISTS和IN的区别是什么 EXISTS ɪɡˈzɪsts 判断子查询是否返回任何行，通常用于检查某个条件是否满足; 满足条件后则返回，大数据量时性能好 IN 检查某个值是否在指定集合中； EXISTS 外=\u003e内判断，满足即停止。最好子表有索引。\nIN =\u003e 先内， 再外匹配内。\n11175 SQL中SELECT、FROM… 的执行顺序是什么？ FROM WHERE： 淘汰的单位是行 GROUP BY HAVING：聚合数据，淘汰的单位是整组 SELECT ORDER BY LIMIT B+树、聚簇索引、主键索引、二级索引 B+树：数据结构\n聚簇索引（主键索引）：叶子节点存储了整行数据，一张表只能有一张(Primary Key)。 使用B+树实现\n二级索引：叶子和非叶子都只存储了Index比较需要的数据。使用B+树实现。因此，索引完，SELECT有其他字段，需要回表根据Primary Key再查一次\n=\u003e 索引覆盖：将SELECT 所需的字段均放置在Index中，就不用回表查询了\n",
  "wordCount" : "994",
  "inLanguage": "en",
  "datePublished": "2025-03-04T00:00:00Z",
  "dateModified": "2025-03-04T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "LongWei"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://121.40.252.207/posts/jobs/mysql/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "LongCoding's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://121.40.252.207/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://121.40.252.207/" accesskey="h" title="𝓛𝓸𝓷𝓰𝓒𝓸𝓭𝓲𝓷𝓰&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="http://121.40.252.207/android-icon-48x48.png" alt="" aria-label="logo"
                    height="30">𝓛𝓸𝓷𝓰𝓒𝓸𝓭𝓲𝓷𝓰&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://121.40.252.207/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="http://121.40.252.207/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="http://121.40.252.207/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://121.40.252.207/categories/" title="🗒️ Categories">
                    <span>🗒️ Categories</span>
                </a>
            </li>
            <li>
                <a href="http://121.40.252.207/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://121.40.252.207/about/" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://121.40.252.207/">Home</a>&nbsp;»&nbsp;<a href="http://121.40.252.207/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      MySQL面试题笔记
    </h1>
    <div class="post-meta"><span title='2025-03-04 00:00:00 +0000 UTC'>March 4, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;994 words&nbsp;·&nbsp;LongWei

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#617-mysql-%e6%95%b0%e6%8d%ae%e6%8e%92%e5%ba%8f-%e5%ae%9e%e7%8e%b0" aria-label="617 MySQL 数据排序 实现？">617 MySQL 数据排序 实现？</a></li>
                <li>
                    <a href="#589-%e4%b8%80%e6%9d%a1sql%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" aria-label="589 一条SQL的执行过程">589 一条SQL的执行过程</a></li>
                <li>
                    <a href="#590-mysql-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" aria-label="590 MySQL 存储引擎">590 MySQL 存储引擎</a></li>
                <li>
                    <a href="#591-mysql%e7%9a%84%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="591 MySQL的索引类型有哪些">591 MySQL的索引类型有哪些</a></li>
                <li>
                    <a href="#mysql%e7%b4%a2%e5%bc%95%e7%9a%84%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%88%99" aria-label="MySQL索引的最左前缀匹配原则？">MySQL索引的最左前缀匹配原则？</a></li>
                <li>
                    <a href="#595-mysql%e7%b4%a2%e5%bc%95%e8%a6%86%e7%9b%96" aria-label="595 MySQL索引覆盖">595 MySQL索引覆盖</a></li>
                <li>
                    <a href="#596-mysql%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8" aria-label="596 MySQL索引下推">596 MySQL索引下推</a></li>
                <li>
                    <a href="#597-%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="597 建立索引注意事项">597 建立索引注意事项</a></li>
                <li>
                    <a href="#598-%e6%8e%92%e6%9f%a5%e7%b4%a2%e5%bc%95%e6%95%88%e6%9e%9c" aria-label="598 排查索引效果？">598 排查索引效果？</a></li>
                <li>
                    <a href="#600-mysql%e7%9a%84b%e6%a0%91%e6%9f%a5%e8%af%a2%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%a8%e8%bf%87%e7%a8%8b" aria-label="600 MySQL的B&#43;树查询数据的全过程">600 MySQL的B+树查询数据的全过程</a></li>
                <li>
                    <a href="#601-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8b%e6%a0%91%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95%e7%bb%93%e6%9e%84" aria-label="601 为什么使用B&#43;树作为索引结构">601 为什么使用B+树作为索引结构</a></li>
                <li>
                    <a href="#602-mysql%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e4%ba%8b%e5%8a%a1-" aria-label="602 MySQL怎么实现事务 ❌❌❌">602 MySQL怎么实现事务 ❌❌❌</a></li>
                <li>
                    <a href="#609-mysql%e6%9c%89%e5%93%aa%e4%ba%9b%e9%94%81" aria-label="609 Mysql有哪些锁">609 Mysql有哪些锁</a></li>
                <li>
                    <a href="#603-mysql%e9%95%bf%e6%97%b6%e9%97%b4%e4%ba%8b%e5%8a%a1%e5%8f%af%e8%83%bd%e9%80%a0%e6%88%90%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" aria-label="603 MySQL长时间事务可能造成什么问题？">603 MySQL长时间事务可能造成什么问题？</a></li>
                <li>
                    <a href="#604-mvcc" aria-label="604 MVCC">604 MVCC</a></li>
                <li>
                    <a href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" aria-label="事务隔离级别">事务隔离级别</a></li>
                <li>
                    <a href="#mysql%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6" aria-label="MySQL主从复制">MySQL主从复制</a></li>
                <li>
                    <a href="#610-mysql%e4%b9%90%e8%a7%82%e9%94%81%e6%82%b2%e8%a7%82%e9%94%81" aria-label="610 MySQL乐观锁&amp;悲观锁">610 MySQL乐观锁&amp;悲观锁</a></li>
                <li>
                    <a href="#616-mysql-sql%e8%b0%83%e4%bc%98" aria-label="616 MySQL SQL调优">616 MySQL SQL调优</a></li>
                <li>
                    <a href="#619-mysql%e5%ae%9e%e7%8e%b0%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb" aria-label="619 MySQL实现读写分离">619 MySQL实现读写分离</a></li>
                <li>
                    <a href="#620-mysql%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e6%9c%ba%e5%88%b6" aria-label="620 MySQL主从复制机制">620 MySQL主从复制机制</a></li>
                <li>
                    <a href="#622--%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9b%e8%a1%8c%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%e4%bb%a5%e5%8f%8a%e5%b8%a6%e6%9c%89%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="622  数据库进行分库分表以及带有的问题">622  数据库进行分库分表以及带有的问题</a></li>
                <li>
                    <a href="#624-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%e5%8f%af%e8%83%bd%e5%bc%95%e5%8f%91%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="624 数据库分库分表可能引发的问题">624 数据库分库分表可能引发的问题</a></li>
                <li>
                    <a href="#625-mysql%e8%8e%b7%e5%8f%96%e6%95%b0%e6%8d%ae%e4%bb%8e%e7%a3%81%e7%9b%98%e4%b8%ad%e5%86%99%e7%9a%84%e5%90%97" aria-label="625 MySQL获取数据，从磁盘中写的吗？">625 MySQL获取数据，从磁盘中写的吗？</a></li>
                <li>
                    <a href="#629-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%8e%a8%e8%8d%90%e5%a4%9a%e8%a1%a8join" aria-label="629 为什么不推荐多表JOIN">629 为什么不推荐多表JOIN</a></li>
                <li>
                    <a href="#630-mysql%e4%b8%ad%e8%a7%a3%e5%86%b3%e6%b7%b1%e5%ba%a6%e5%88%86%e9%a1%b5%e9%97%ae%e9%a2%98" aria-label="630 MySQL中解决深度分页问题">630 MySQL中解决深度分页问题</a></li>
                <li>
                    <a href="#1418-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%a7%86%e5%9b%be" aria-label="1418 数据库视图">1418 数据库视图</a></li>
                <li>
                    <a href="#1479-%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e4%b8%8d%e6%8e%a8%e8%8d%90%e4%b8%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95" aria-label="1479 什么情况下，不推荐为数据库建立索引">1479 什么情况下，不推荐为数据库建立索引</a></li>
                <li>
                    <a href="#3179-%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8d%e5%81%9c%e6%9c%8d%e8%bf%81%e7%a7%bb" aria-label="3179 数据库不停服迁移">3179 数据库不停服迁移</a></li>
                <li>
                    <a href="#4040-mysql%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95" aria-label="4040 MySQL数据库的性能优化方法">4040 MySQL数据库的性能优化方法</a></li>
                <li>
                    <a href="#1219-%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%89%e5%a4%a7%e8%8c%83%e5%bc%8f" aria-label="1219 数据库三大范式">1219 数据库三大范式</a></li>
                <li>
                    <a href="#1482-mysql%e4%b8%adexists%e5%92%8cin%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="1482 MySQL中EXISTS和IN的区别是什么">1482 MySQL中EXISTS和IN的区别是什么</a></li>
                <li>
                    <a href="#11175-sql%e4%b8%adselectfrom-%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f%e6%98%af%e4%bb%80%e4%b9%88" aria-label="11175 SQL中SELECT、FROM&hellip; 的执行顺序是什么？">11175 SQL中SELECT、FROM&hellip; 的执行顺序是什么？</a></li>
                <li>
                    <a href="#b%e6%a0%91%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95" aria-label="B&#43;树、聚簇索引、主键索引、二级索引">B+树、聚簇索引、主键索引、二级索引</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="617-mysql-数据排序-实现">617 MySQL 数据排序 实现？<a hidden class="anchor" aria-hidden="true" href="#617-mysql-数据排序-实现">#</a></h3>
<ol>
<li>Order By 命中索引(包括索引字段)，使用索引排序(有序)，效率最高效</li>
<li>否则使用文件排序，文件少=&gt; 内存排序 sort_buffer</li>
<li>文件大=&gt;外部排序，归并排序</li>
</ol>
<p>内部排序细节：</p>
<p><strong>双路排序(待排序的列数据太大了)</strong>：使用row_id(回查表) + sort_field</p>
<p>​		排好序后，使用row_id将完整的记录取出来</p>
<p>单路排序(待排序数据大小能接受)</p>
<p>​	直接拍，不会查表，直接把拍好的结果返回</p>
<p>外部排序：</p>
<p>拆分小的，外部多路归并排序，小=&gt;大</p>
<p>外部归并排序 =&gt; 先分段排序，每一段调入内存执行快排</p>
<p>​                        =&gt; 归并阶段，因为每子段都是有序的 =&gt; 多路归并排序</p>
<h3 id="589-一条sql的执行过程">589 一条SQL的执行过程<a hidden class="anchor" aria-hidden="true" href="#589-一条sql的执行过程">#</a></h3>
<ol>
<li>先通过<strong>连接器</strong>校验权限</li>
<li>利用<strong>分析器</strong>进行SQL语句词法分析和语法分析，构建解析树</li>
<li>利用<strong>优化器</strong>选择合适的索引和表连接顺序，最终选择一条最佳的执行计划</li>
<li>利用<strong>执行器</strong>，调用引擎层查询数据，返回结果集</li>
</ol>
<p>具体：Select * from user where id = 1;</p>
<img src="http://sthda9dn6.hd-bkt.clouddn.com/FssKKPCKzeVJv4TEPdMldct1M8z4" alt="image-20250305222939319" style="zoom:50%;" />
<ul>
<li>
<p>SQL =&gt; Server层<strong>连接器</strong>，权限校验，账号是否有资格获取。无=&gt; Access denied for user。  连接成功后，空闲一段时间会断开</p>
</li>
<li>
<p><strong>分析器(查询解析)</strong> =&gt;</p>
<ul>
<li>语法分析：SQL  : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。</li>
<li>语义分析：语法是否有误 =&gt; you have an error in your SQL syntax (字段、表|存在？)   分析解析树语法正确性</li>
</ul>
</li>
<li>
<p><strong>优化器</strong>(查询优化)=&gt;</p>
<ul>
<li>优化SQL，比如：选择哪个索引、调整多个表的连接顺序</li>
</ul>
</li>
<li>
<p><strong>执行器</strong>（查询执行）</p>
<ul>
<li>校验用户对表的权限，根据存储引擎查询数据，遍历</li>
</ul>
</li>
</ul>
<p>=&gt; 返回结果集</p>
<h3 id="590-mysql-存储引擎">590 MySQL 存储引擎<a hidden class="anchor" aria-hidden="true" href="#590-mysql-存储引擎">#</a></h3>
<ul>
<li>
<p>InnoDB</p>
<ul>
<li>
<p>提供<strong>事务</strong>、<strong>行级锁</strong>和外键</p>
</li>
<li>
<p>提供高并发性能</p>
</li>
<li>
<p><strong>B+树索引</strong></p>
</li>
<li>
<p><strong>MVCC</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="591-mysql的索引类型有哪些">591 MySQL的索引类型有哪些<a hidden class="anchor" aria-hidden="true" href="#591-mysql的索引类型有哪些">#</a></h3>
<p>数据结构角度：</p>
<ul>
<li>B+树索引：
<ul>
<li>通过树型结构 =&gt; 适合范围查询between和精确查=。</li>
<li>叶子节点双向链表连接</li>
<li>比B树具备更少的IO次数</li>
</ul>
</li>
</ul>
<p>InnoDB+树索引结构上看</p>
<ul>
<li>聚簇索引(主键构建)：
<ul>
<li>非叶子节点存储索引值</li>
<li><strong>叶子节点存储完整的数据行数据</strong>，可以直接访问完整数据</li>
<li>每个表只能有一个聚簇索引</li>
</ul>
</li>
<li>非聚簇索引 (二级索引)
<ul>
<li>非叶子节点存储索引值</li>
<li>叶子节点存储主键和对应索引列，查询非对应索引列，则需要回表(根据主键)，增加额外的IO（SELELCT * 慎重）</li>
</ul>
</li>
</ul>
<p>索引:</p>
<ul>
<li>
<p>主键索引</p>
</li>
<li>
<p>唯一索引</p>
</li>
<li>
<p>普通索引</p>
</li>
<li>
<p>单列索引 &amp; 联合索引</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="ln">1</span><span class="cl"><span class="err">主键：</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">Key</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="err">唯一：</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w"></span><span class="k">Create</span><span class="w"> </span><span class="k">unique</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">username</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="err">联合：</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w"></span><span class="k">Create</span><span class="w"> </span><span class="k">INdex</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">email</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><h3 id="mysql索引的最左前缀匹配原则">MySQL索引的最左前缀匹配原则？<a hidden class="anchor" aria-hidden="true" href="#mysql索引的最左前缀匹配原则">#</a></h3>
<p>针对联合索引</p>
<p>联合索引在B+树种的排列方式遵循“从左到右”的顺序 e.g. (first_name, last_name, age) 会按照 这个顺序进行索引</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="ln">1</span><span class="cl">                      (Alice, Black, 35)
</span></span><span class="line"><span class="ln">2</span><span class="cl">                          |
</span></span><span class="line"><span class="ln">3</span><span class="cl">  -------------------------------------------------------------
</span></span><span class="line"><span class="ln">4</span><span class="cl">  |                |                     |                |
</span></span><span class="line"><span class="ln">5</span><span class="cl">(Alice, Brown, 25)  (Alice, Smith, 30) (Bob, Smith, 20) (Bob, White, 19)   
</span></span></code></pre></div><p>查询时候WHERE 条件顺序最好和索引一致，否则跳过最左侧会导致无法利用该索引</p>
<p>=&gt; 要保证索引命中，建议索引顺序一致</p>
<ul>
<li>
<p>不能跳过第一个索引</p>
</li>
<li>
<p>可以部分匹配但第一个一定要在</p>
</li>
</ul>
<p>index: (a, b, c)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="err">✔️</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="err">✔️</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">c</span><span class="o">=</span><span class="mi">1</span><span class="err">✔️</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="err">❌❌❌</span><span class="w">
</span></span></span></code></pre></div><h3 id="595-mysql索引覆盖">595 MySQL索引覆盖<a hidden class="anchor" aria-hidden="true" href="#595-mysql索引覆盖">#</a></h3>
<p>指二级索引包含了查询所需的所有字段  - 一级索引(Primary key，唯一) ˈpraɪməri - 二级索引(其他索引)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln">1</span><span class="cl"><span class="o">#</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_name_hiredate</span><span class="w"> </span><span class="p">(</span><span class="n">last_name</span><span class="p">,</span><span class="w"> </span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="n">hire_date</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">last_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">first_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w"></span><span class="err">则不需要回表查询，因为这个</span><span class="n">SQL会根据联合索引进行查询</span><span class="err">，并且查询的条件列包含所需的数据</span><span class="w">
</span></span></span></code></pre></div><h3 id="596-mysql索引下推">596 MySQL索引下推<a hidden class="anchor" aria-hidden="true" href="#596-mysql索引下推">#</a></h3>
<p>应用在联合索引上，减少回表查询。MySQL自动应用的优化技术</p>
<p><strong>主要是将条件索引列的过滤操作下推到存储引擎层，减少不必要的数据传输</strong></p>
<p>通过二级索引查到主键id后回表再进行where条件过滤</p>
<p>=&gt; 二级索引查到数据后直接where条件过滤一遍，再进行回表查询，减少回表的次数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="o">#</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="err">联合索引：</span><span class="n">index_age_grade</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">90</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">85</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Charlie&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">95</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;David&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">80</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w"></span><span class="o">=&gt;</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">grade</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">90</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">没有索引下推：</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="mi">1</span><span class="p">.</span><span class="w"> </span><span class="err">先根据</span><span class="n">age查找到所有结果</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w"></span><span class="mi">2</span><span class="p">.</span><span class="w"> </span><span class="err">返回所有结果数据到服务器层</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w"></span><span class="mi">3</span><span class="p">.</span><span class="w"> </span><span class="err">服务器层过滤</span><span class="n">grade</span><span class="o">&gt;</span><span class="mi">90</span><span class="err">的数据</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">索引下推</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w"></span><span class="mi">1</span><span class="p">.</span><span class="w"> </span><span class="err">先根据</span><span class="n">age查找到所有结果</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w"></span><span class="mi">2</span><span class="p">.</span><span class="w"> </span><span class="err">存储引擎层直接过滤</span><span class="n">grade</span><span class="o">&gt;</span><span class="mi">90</span><span class="err">的数据</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w"></span><span class="mi">3</span><span class="p">.</span><span class="w"> </span><span class="err">返回数据给服务器层</span><span class="w">
</span></span></span></code></pre></div><h3 id="597-建立索引注意事项">597 建立索引注意事项<a hidden class="anchor" aria-hidden="true" href="#597-建立索引注意事项">#</a></h3>
<ol>
<li>不能盲目建立，因为维护需要代价</li>
<li>表的修改频率远大于查询频率 =&gt; 维护代价大</li>
</ol>
<h3 id="598-排查索引效果">598 排查索引效果？<a hidden class="anchor" aria-hidden="true" href="#598-排查索引效果">#</a></h3>
<p>在SQL语句前，使用EXPLAIN关键字，查看SQL语句的执行信息</p>
<ul>
<li>联合索引 =&gt; 符合最左前缀顺序</li>
<li>索引中使用运算或者函数，like进行全盘扫描，对值进行了处理，则会使索引失效</li>
<li>破坏最左匹配</li>
<li>in字段</li>
<li>order by 为使用索引</li>
</ul>
<h3 id="600-mysql的b树查询数据的全过程">600 MySQL的B+树查询数据的全过程<a hidden class="anchor" aria-hidden="true" href="#600-mysql的b树查询数据的全过程">#</a></h3>
<ul>
<li>查询从跟节点出发，比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定往下哪个分支走，从上到下定位到叶子节点</li>
<li>叶子节点存储着数据行记录，但一页的大小有16kb，存储的数据行不只一条</li>
<li>叶子节点中的数据行以组的形式划分，利用页目录结构，通过二分查找定位到对应的组</li>
<li>定位到组后，利用链表遍历=&gt;row</li>
</ul>
<h3 id="601-为什么使用b树作为索引结构">601 为什么使用B+树作为索引结构<a hidden class="anchor" aria-hidden="true" href="#601-为什么使用b树作为索引结构">#</a></h3>
<ul>
<li>高效的查询性能
<ul>
<li><strong>自平衡</strong>，根到叶子路径长度相同 O(logn)</li>
</ul>
</li>
<li>树高长的不会过快，使得查询磁盘的IO次数减少
<ul>
<li>非叶子节点只存放索引值和页面指针</li>
<li>每一页中能够容纳更多的记录，减少查询的IO次数</li>
</ul>
</li>
<li>范围查询能力强</li>
<li>叶子节点通过链表连接，定位到叶子节点，根据范围查询只需要顺序扫描链表</li>
</ul>
<p>B树</p>
<ul>
<li>每个节点都存储了完整的数据</li>
<li>B树叶子节点没有连接指针</li>
</ul>
<h3 id="602-mysql怎么实现事务-">602 MySQL怎么实现事务 ❌❌❌<a hidden class="anchor" aria-hidden="true" href="#602-mysql怎么实现事务-">#</a></h3>
<p><strong>通过锁、Redo Log、Undo Log、 MVCC实现事务</strong></p>
<ol>
<li>
<p>利用<strong>锁</strong>(行锁、间隙锁等)机制，控制数据的并发修改，满足事务的<strong>隔离性</strong></p>
</li>
<li>
<p><strong>Redo Log</strong>(重做日志)，它记录事务对数据库的修改，当MySQL宕机了，通过重放redo log可以恢复数据，满足事务的持久性</p>
</li>
<li>
<p><strong>Undo Log</strong>(回滚日志)，记录事务的反向操作，保持数据的历史版本，用于事务的回滚，使事务执行失败后可以恢复到之前的样子。实现原子性和隔离性</p>
</li>
<li>
<p><strong>MVCC 多版本并发控制</strong>，满足非锁读的需求，提供读写并发，实现了读已提交和可重复读两种隔离级别</p>
</li>
</ol>
<ul>
<li>读已提交：每次查询生成新的 ReadView，可能导致多次查询结果不一致</li>
<li>可重复读：事务启动时生成 ReadView，保证整个事务中查询结果一致</li>
</ul>
<p>事务工作流程：</p>
<img src="http://sthda9dn6.hd-bkt.clouddn.com/FuXst7sZuH37L19aO7agTeEDTtlN" alt="image-20250306141944766" style="zoom:33%;" />
<p>Redo Log(重做日志)：</p>
<p>=&gt; 保证事务的持久性，即使宕机了也能恢复提交的数据</p>
<p><strong>版本链</strong>示意</p>
<img src="http://sthda9dn6.hd-bkt.clouddn.com/FpWNTahmxnM3lVx0o9SRR3SffRym" alt="image-20250306142039417" style="zoom:50%;" />
<p>​</p>
<h3 id="609-mysql有哪些锁">609 Mysql有哪些锁<a hidden class="anchor" aria-hidden="true" href="#609-mysql有哪些锁">#</a></h3>
<p>粒度分类：</p>
<ul>
<li>
<p>全局锁：整个数据库加锁，只读</p>
</li>
<li>
<p>行级锁：细粒度</p>
<ul>
<li>对特定的行加锁，允许其他事务并发访问不同的行，适用于高并发的场景</li>
</ul>
</li>
<li>
<p>表级锁  粗粒度</p>
<ul>
<li>对整个表进行加锁，其他事务无法对该表进行操作</li>
</ul>
</li>
</ul>
<p>属性分类：</p>
<ul>
<li>
<p>共享锁 S锁 Shared lock</p>
<ul>
<li>允许多个事务并发<strong>读</strong>同一资源，但是不允许修改，只有释放共享锁后，其他事务才能获取排他锁</li>
</ul>
</li>
<li>
<p>排他锁 Exclusive lock X锁</p>
<ul>
<li>只允许一个事务读写资源，互斥，独享</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">-- 添加共享锁
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">LOCK</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="k">SHARE</span><span class="w"> </span><span class="k">MODE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="c1">-- 共享锁
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">SHARE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="c1">-- 排他锁
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>
<p>记录锁：锁定特定的行记录</p>
</li>
<li>
<p>间隙锁</p>
<ul>
<li>针对索引中两个记录之间的间隙加锁，防止其他事务在这个间隙中插入新的数据，避免幻读。锁定行与行之间的空间 <strong>阻止新的记录的插入</strong></li>
</ul>
</li>
<li>
<p>临键锁</p>
<ul>
<li>锁定具体行和其前面的间隙，确保范围内不会幻读</li>
</ul>
</li>
</ul>
<h3 id="603-mysql长时间事务可能造成什么问题">603 MySQL长时间事务可能造成什么问题？<a hidden class="anchor" aria-hidden="true" href="#603-mysql长时间事务可能造成什么问题">#</a></h3>
<p>问题：</p>
<ul>
<li>长时间事务 =&gt; 长时间的锁竞争+阻塞资源
<ul>
<li>其他事务也需要对应的锁，但是这个锁长时间拿不到，阻塞</li>
<li>部分业务的阻塞会影响到其他服务，导致系统出现严重的服务崩盘</li>
</ul>
</li>
<li>死锁风险
<ul>
<li>多个事务相互等待对方释放锁，导致系统无法继续执行</li>
</ul>
</li>
<li>回滚导致时间的浪费
<ul>
<li>执行了很长，但是快结束出现异常 =&gt; 事务回滚需要很长的时间</li>
</ul>
</li>
</ul>
<p>长时间事务如何解决</p>
<ul>
<li>
<p>拆分成一小份一小份的短事务</p>
<p>时间？ 创造索引条件，得到表的主键最大值和最小值，切分成一小份一小份的区间在执行</p>
</li>
<li>
<p>删除大量的数据 =&gt; 在新的表中插入相对小的数据</p>
</li>
</ul>
<h3 id="604-mvcc">604 MVCC<a hidden class="anchor" aria-hidden="true" href="#604-mvcc">#</a></h3>
<p>[数据版本控制<strong>隐藏字段和指针</strong>、事务<strong>视图ReadView</strong>]</p>
<p>Multi-Version Concurrency Control 多版本并发控制 =&gt; <strong>允许事务同时读写数据库，而无需相互等待</strong></p>
<ul>
<li><strong>提高并发性能</strong> &amp; <strong>避免读写冲突</strong> &amp; <strong>减少锁竞争</strong></li>
</ul>
<p>MVCC中，为每个事务创建一个数据快照，当数据被修改时，MySQL不会立即覆盖原有数据，而是生成新版本的记录。每个记录都保留着相应的版本号</p>
<ul>
<li>读写冲突：传统读写或互斥。解决方法：多版本方式，读旧版本数据，写在新版本上，从而避免读写冲突。</li>
<li>锁竞争：传统方式需要竞争锁，解决方式：通过版本控制替代锁。</li>
<li>事务隔离级别实现：传统机制：锁。解决方式：版本控制。</li>
</ul>
<p>MVCC为每条数据维护多个版本</p>
<p>每个<strong>版本</strong>包括：</p>
<ul>
<li>版本号：标识创建版本的事务ID</li>
<li>时间戳：创建时间</li>
<li>数据内容</li>
</ul>
<p><strong>读操作</strong>：</p>
<p>根据事务的隔离级别和当前时间戳，选择合适的数据版本。</p>
<ul>
<li>在<strong>读已提交</strong>下隔离级别下：读操作会读取已提交的最新版本</li>
<li>在<strong>可重复读</strong>隔离级别下：读操作会读取事务开始时的数据版本</li>
</ul>
<p><strong>写操作</strong>:</p>
<ul>
<li>=&gt; 创建新的数据新版本，而不是修改旧版本数据</li>
<li>旧版本数据会被保留，直到没有任何事务引用 &lt;= 垃圾回收</li>
</ul>
<p>MVCC优势：</p>
<ul>
<li>高并发； 灵活的隔离级别； 减少锁竞争； <strong>一致性视图</strong></li>
</ul>
<p>隐藏字段：</p>
<p>每行记录除了自己定义的字段外，还有一些重要的隐藏字段</p>
<ul>
<li>db_row_id： 没有定义Primary Key，默认用这个为Index</li>
<li>db_trx_id：最近对这个记录修改的事务ID</li>
<li>db_roll_ptr: 回滚指针，指向这个记录的上一个版本，指向Undo Log中的上一个快照版本的地址</li>
</ul>
<img src="http://sthda9dn6.hd-bkt.clouddn.com/FjlK-zxw1Ywj_ETnzc4o3_1y5Yu9" alt="image-20250306211450491" style="zoom: 50%;" />
<p>多版本之间串联起来形成一条版本链。 不同事务可以无锁的<strong>读</strong>取不同版本的数据(普通读)。普通读和写不会阻塞</p>
<p>写操作可以继续写，就是新的数据版本不会立即对其他事务可见，只有事务提交后，新版本的记录才会可见</p>
<p>MySQL InnoDB通过Undo Log 操作 和 ReadView实现</p>
<p><strong>Undo Log</strong> 记录数据修改之前的状态的日志，作用如下：</p>
<ul>
<li>事务回滚：撤销未提交的事务修改</li>
<li>实现MVCC：提供历史版本数据，支持一致性读</li>
</ul>
<p>=&gt; 当事务修改数据时，InnoDB会将数据的旧版本写入Undo Log中</p>
<p>=&gt; 当Undo Log没被任务事务引用时，会被垃圾回收</p>
<p><strong>ReadView</strong> 读视图</p>
<p>事务某时刻创建的数据库快照，用于确定哪些数据版本对事务可见 =&gt; 实现事务隔离性</p>
<ul>
<li>
<p>核心字段</p>
<ul>
<li>m_ids: 当前活动事务ID列表</li>
<li>min_trx_id: m_ids中最小事务的ID</li>
<li>max_trx_id</li>
<li>creator_trx_id: 创建该ReadView事务的ID</li>
</ul>
</li>
<li>
<p>可见性规则</p>
<ul>
<li>
<p>对于每条数据的版本，ReadView会根据一下规则判断是否可见</p>
</li>
<li>
<ol>
<li>
<p>当数据版本的事务ID &lt; min_trx_id</p>
<p>=&gt; 数据版本以及提交(<strong>过去的事务</strong>)，<strong>可见</strong></p>
</li>
<li>
<p>当数据版本的事务ID &gt;= max_trx_id</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>​					  =&gt; 说明数据版本是<strong>未来事务</strong>创建的，<strong>不可见</strong></p>
<p>​					3. 数据版本的事务ID 在 m_ids中 ⭐⭐⭐</p>
<p>​						=&gt; 说明他是由<strong>未提交</strong>的事务创建的， <strong>不可见,</strong>  否则可见</p>
<pre><code>如果当前数据版本的 trx id 大小在 min trx id 和 max trx id 之间，此时 trx id 若在 m ids 中，说明修改这条数据的事务此时还未提交，所以不可见，若不在m ids 中，表明事务已经提交，可见。
</code></pre>
<p>​			 	   4. 数据版本的事务ID == creator_trx_id</p>
<p>​	                    =&gt; 自己创建的，可重入，当然<strong>可见</strong>了</p>
<p>​		可见性取决于ReadView的快照机制 =&gt; ReadView<strong>创建时间</strong> 决定了事务能看到哪些已提交的数据。</p>
<p>MVCC</p>
<p>解决脏读：事务只能读取已提交的数据记录；可见性控制 =&gt; 去UndoLog中找历史记录</p>
<p>解决不可重复读：ReadView</p>
<p>❗不能解决幻读：比当前事务Id小的事务提交了，那么新出现的记录可以被看到，特别是范围查询的时候</p>
<p>使用场景：</p>
<ul>
<li>MVCC：读多写少的场景 =&gt; 商品库存查询？ 读事务不会被写事务阻塞</li>
<li>对于银行金额变更场景 =&gt; 锁</li>
</ul>
<h3 id="事务隔离级别">事务隔离级别<a hidden class="anchor" aria-hidden="true" href="#事务隔离级别">#</a></h3>
<p><strong>事务的ACID特性</strong>：Atomicity, Consistency, Isolation, Durability</p>
<p><strong>数据一致性问题</strong>：</p>
<ul>
<li>脏读：事务A读取了事务B尚未提交的数据，此时事务B回滚，那么A读的数据是脏数据(无效)</li>
<li>幻读：同一事务中，多次执行的相同查询，得到的结果集不一致。
<ul>
<li>其他事务插入新的数据并提交</li>
</ul>
</li>
<li>不可重复读：同一事务，多次读取的同一数据，结果不一致
<ul>
<li>因为事务执行期间，其他事务对结果进行了修改</li>
</ul>
</li>
</ul>
<p><strong>事务隔离级别</strong>：避免上述数据不一致问题</p>
<ul>
<li>读未提交：允许事务读取其他事务未提交的数据。 会引起：脏读、幻读、不可重复读；</li>
<li>读已提交：事务只能读取其他事务已提交的数据。避免了：在脏读；(默认)</li>
<li>可重复读：加锁(行锁)，确保事务多次读取同一数据的一致性。避免了：脏读、不可重复读；可能：幻读</li>
<li>串行化：事务完全串行执行：锁定整个表或者范围来实现。避免：脏读、幻读、不可重复读</li>
</ul>
<h3 id="mysql主从复制">MySQL主从复制<a hidden class="anchor" aria-hidden="true" href="#mysql主从复制">#</a></h3>
<p>核心是基于二进制日志(BinLog File)进行数据同步</p>
<ul>
<li>主库(Master)记录变更
<ul>
<li>任何对数据库进行变更的操作都会被记录到BinLog中。Update Delete Insert</li>
</ul>
</li>
<li>从库Slave获取Binlog
<ul>
<li>从库通过IO线程连接主库，读取Binlog，并存入本地<strong>中继日志</strong>中(Relay log)</li>
</ul>
</li>
<li>从库Slave 回放Binlog
<ul>
<li>从库SQL线程解析Relay Log，执行相同的SQL语句，进而保持与主库相同的数据</li>
</ul>
</li>
</ul>
<p>一主多从</p>
<ul>
<li>一个主库，多个从库，每个从库独立同步主库数据</li>
</ul>
<p>主从复制的优势</p>
<ul>
<li>数据冗余 =&gt; 更安全</li>
<li>读写分离 =&gt; 主库写，从库读，提高性能</li>
<li>高可用性 =&gt; 主库故障 切换从库，提高系统可靠性</li>
</ul>
<h3 id="610-mysql乐观锁悲观锁">610 MySQL乐观锁&amp;悲观锁<a hidden class="anchor" aria-hidden="true" href="#610-mysql乐观锁悲观锁">#</a></h3>
<p><strong>乐观锁</strong>：比如CAS机制，不加锁实现并发。并发性能高。 <strong>比较版本号和时间戳实现</strong></p>
<p><strong>悲观锁</strong>：每次操作都<strong>加锁</strong>，互斥操作，数据一致性要求高的场景。并发性能低</p>
<ul>
<li></li>
</ul>
<p>​</p>
<h3 id="616-mysql-sql调优">616 MySQL SQL调优<a hidden class="anchor" aria-hidden="true" href="#616-mysql-sql调优">#</a></h3>
<p>通过分析慢SQL，利用explain分析查询语句的执行计划，识别性能瓶颈，优化查询语句</p>
<ul>
<li>
<p>合理设计索引，利用联合索引进行覆盖索引的优化</p>
<ul>
<li>覆盖索引：让常用的字段都在索引中，这样就可以减少回表查询的开销</li>
<li>索引下层：<strong>过滤掉不符合查询条件的数据</strong>，减少回表操作 <strong>自动的</strong></li>
</ul>
</li>
<li>
<p>避免 SELECT *，只查询必要的字段</p>
</li>
<li>
<p>避免在SQLWHRER中执行函数计算，使得索引失效</p>
</li>
<li>
<p>避免%LIKE，导致全屏扫描</p>
</li>
<li>
<p>注意联合索引需满足最左匹配原则</p>
</li>
<li>
<p>不要对无索引字段进行排序</p>
<p>通过业务的优化，进行缓存，减少对数据库的访问</p>
</li>
<li>
<p>减少多表查询的情况</p>
<ul>
<li>JOIN操作，数据量大时，容易导致查询速度慢，影响数据库性能
<ul>
<li>避免频繁使用JOIN多张大表，而是<strong>分步</strong>查询或缓存</li>
<li>必要时使用冗余存储，减少JOIN。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一次查大量数据的优化方式</p>
<ul>
<li>
<p>分页查询</p>
<ul>
<li>
<p>使用LIMIT和OFFSET，每次只查一部分数据</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="o">???</span><span class="w"> </span><span class="k">OFFSET</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>分批次查询：</p>
<pre><code>           ```sql
           SELECT ... FROM ... WHERE id &gt; 1000 ORDER BY id LIMIT 100;
           ```
</code></pre>
</li>
</ul>
<p>回答：索引相关：</p>
<ul>
<li>查询的时候，满足最左前缀匹配原则</li>
<li>最小查询，只查询所需要的必要信息。<strong>减少回表情况</strong></li>
<li><strong>利用好索引</strong>，加速检索。 避免全盘扫描的情况
<ul>
<li>
<ol>
<li>避免 Like % 全盘匹配</li>
<li>避免WHere中对字段进行函数操作，使得索引失效</li>
<li>不要对无关字段进行排序</li>
</ol>
</li>
</ul>
</li>
<li><strong>利用好缓存</strong>，直接减少数据库的访问</li>
</ul>
<h3 id="619-mysql实现读写分离">619 MySQL实现读写分离<a hidden class="anchor" aria-hidden="true" href="#619-mysql实现读写分离">#</a></h3>
<p><strong>读操作次数远大于写操作</strong></p>
<p>将读操作分摊到从数据库中。主数据库负责写操作。然后通过主从复制，同步数据。</p>
<p>数据一致性要求高的场景</p>
<p>⭐1. 关键事务必须强制从主库中读取数据</p>
<ul>
<li>支付订单状态</li>
<li>扣减库存等等</li>
</ul>
<p>2.半同步控制</p>
<p>当事务提交后，至少有一个从库确认接收到数据，才认为数据写入成功</p>
<p>3.业务层解决，将数据写入Redis中，优先从缓存中读取数据</p>
<p>读写分离 =&gt; 将压力分摊到子库中，提高性能</p>
<ul>
<li>同步 =&gt; 数据一致性 =&gt; 全同步， 半同步</li>
</ul>
<hr>
<h3 id="620-mysql主从复制机制">620 MySQL主从复制机制<a hidden class="anchor" aria-hidden="true" href="#620-mysql主从复制机制">#</a></h3>
<p>应用场景数据备份or主从数据同步</p>
<ul>
<li>同步复制：将binlog file复制到所有从库，等所有从库响应了，主库才响应客户端 （性能差，数据一致性高）</li>
<li>半同步复制：主库等待至少一个从库确认收到数据（性能折中，数据一致性较高）</li>
<li>异步复制：主库不用等待从库确认（性能高，数据一致性差）</li>
</ul>
<p>如何实现同步过程</p>
<ul>
<li>提交事务请求 =&gt; 主库 =&gt; 同时写入<strong>binlog file</strong>，更新数据并相应客户端，并推送binlog更新事件</li>
<li>binlog file 被主库的dump线程发送给从库</li>
<li>从库<strong>IO线程</strong>接收binlog，并写入Relay log(中继日志)中，缓冲</li>
<li>从库<strong>SQL线程</strong>从Relay log重写事件到从库数据库中。</li>
</ul>
<p><img alt="image-20250321101913192" loading="lazy" src="http://sthda9dn6.hd-bkt.clouddn.com/Fnipxneje3YSIkxYJSlw7XNF833G"></p>
<h3 id="622--数据库进行分库分表以及带有的问题">622  数据库进行分库分表以及带有的问题<a hidden class="anchor" aria-hidden="true" href="#622--数据库进行分库分表以及带有的问题">#</a></h3>
<p><strong>分库分表策略</strong></p>
<ul>
<li>**水平分表：**将一张表的数据，放在两个表中。例如根据ID</li>
<li>**垂直分表：**将一张表不同列拆分到多个表中，⭐减少每张表的字段数提高查询效率。例如，用户表可以拆分为基本信息和详细信息表。</li>
<li>**水平分库：**将相同表结构复制一份到另一张表中，减少单一数据库的读写压力。</li>
<li>**垂直分库：**根据业务功能，将表分到不同数据库中。例如将用户数据、商品数据分别存储到不同的数据库中。</li>
</ul>
<p><strong>为什么需要分库分表？</strong></p>
<p>随着用户越来越多，导致表数据量大(数据堆积)，读写请求多(并发量高)。</p>
<p>=&gt;导致 性能瓶颈，单一数据库性能有限。</p>
<ul>
<li>分表：100w中找，和1w中找还是不一样的。可以先hash计算到底在哪个数据库，再具体执行。</li>
<li>分库：可以按业务or功能不同，将请求分配到多态服务器上，降低单一服务器压力。</li>
</ul>
<h3 id="624-数据库分库分表可能引发的问题">624 数据库分库分表可能引发的问题<a hidden class="anchor" aria-hidden="true" href="#624-数据库分库分表可能引发的问题">#</a></h3>
<p>单机 =&gt; 分布式</p>
<ul>
<li><strong>事务问题：<strong>会出现</strong>事务的数据不一致问题</strong>，需要使用分布式事务解决。</li>
<li><strong>JOIN连表问题：</strong> 跨服务器无法JOIN表，业务中实现关联，或者使用冗余字段。</li>
<li>**全局唯一ID问题：**单机，使用自增长的ID即可，分布式必须使用全局唯一ID发号器生成唯一ID。</li>
<li>**排序问题：**上推到业务中实现。</li>
<li>**count问题：**业务代码中累加。</li>
</ul>
<h3 id="625-mysql获取数据从磁盘中写的吗">625 MySQL获取数据，从磁盘中写的吗？<a hidden class="anchor" aria-hidden="true" href="#625-mysql获取数据从磁盘中写的吗">#</a></h3>
<p>MySQL中，并不总是从磁盘中读取。利用缓存机制，提高读取性能。</p>
<p>mysql8.0中有查询缓存，只有sql相同时才会命中，命中率低，在8.0后移除了</p>
<img src="http://sthda9dn6.hd-bkt.clouddn.com/FkN2goD3UXaVgUTWStD5Ek0vhRbU" alt="image-20250321102938732" style="zoom:50%;" />
<p>buffer pool(old sublist, young sublist), 里面存储了一个一个的数据页，mysql会从buffer pool中找，找到就返回。</p>
<p>=&gt; 一块<strong>内存</strong>空间，访问某个数据(磁盘中)时，会将包括该数据的页加载到内存中。页大小16KB，局部性原理，以后对该页的修改和访问都在buffer pool中进行。</p>
<p>=&gt; 内存淘汰策略：变体的LRU(least recently used最近最少使用)。 buffer pool将数据分为年轻代和老年代(默认5:3)，当数据从磁盘调到内存中时，<del>因为空间时间局部性</del>，新的数据会放在老年队列中，当1s中没有再次访问时才转到年轻队列中。</p>
<p>=&gt; 如果<strong>直接</strong>放在年轻代中，可能会把热点数据淘汰掉</p>
<p>=&gt; 1s，时间窗口，渡过这个时间还被访问认为是热点数据。</p>
<hr>
<h3 id="629-为什么不推荐多表join">629 为什么不推荐多表JOIN<a hidden class="anchor" aria-hidden="true" href="#629-为什么不推荐多表join">#</a></h3>
<p>数据量大的时候，多表JOIN，数据库需要对联接的每个表进行扫描，会消耗大量的CPU和内存资源。 性能比较低</p>
<p><strong>数据库往往是我们系统的弱点</strong>，很多情况性能瓶颈都在数据库，<strong>因此我们需要尽可能避免把压力放在数据库上</strong>。</p>
<p>JOIN连接表的时候，需要关注<strong>被驱动表</strong>的<strong>查询</strong>是否能够命中索引，不然会导致全表扫描。</p>
<p><strong>尽可能让小表做驱动表</strong>，因为驱动表需要全表扫描，而被驱动表是通过索引查询的。且被驱动表最好能够命中索引。</p>
<p>例子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="n">join</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="nf">on</span><span class="w"> </span><span class="p">(</span><span class="n">a1</span><span class="p">.</span><span class="na">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a2</span><span class="p">.</span><span class="na">a</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>小表有A行，大表有B行。每次扫描A，每行都需要去大表里面查，时间LogB(命中索引)，假设存在回表，那么为2*LogB的查询时间。有A行，那么查B表的时间为=&gt;A*2*LogB；查A表的时间为A,total =&gt; A+A*2*LogB。</p>
<p>JOIN SQL查询的流程</p>
<ul>
<li>扫描A表(小表)
<ul>
<li>读取A表的所有行，及A次操作</li>
</ul>
</li>
<li>查询B表
<ul>
<li>A行 * LogB(命中索引的查询时间) * 2(回表时间)</li>
</ul>
</li>
<li>=&gt; A + A*2*LogB</li>
</ul>
<h3 id="630-mysql中解决深度分页问题">630 MySQL中解决深度分页问题<a hidden class="anchor" aria-hidden="true" href="#630-mysql中解决深度分页问题">#</a></h3>
<p>深度分页是指数据量很大的时候，按照分页访问后面的数据，例如<code>limit 99999, 10</code>，这回使得数据库扫描前面的99999条数据，才能得到最终的10条数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">LIMIT</span><span class="w"> </span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">;</span><span class="w">  </span><span class="c1">-- 偏移量， 返回行数。 会扫描起点到num1整段记录
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">LIMIT</span><span class="w"> </span><span class="n">num1</span><span class="p">;</span><span class="w">        </span><span class="c1">-- 返回行数
</span></span></span></code></pre></div><p><strong>解决方法：</strong></p>
<ul>
<li><em><strong>子查询：</strong></em> 子查询 + 记录上一次查询的 Last ID</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tabel</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w"></span><span class="k">and</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">tabel</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">99999</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w"></span><span class="c1">-- 传递上一次查询的最后一个ID
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">last_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h3 id="1418-数据库视图">1418 数据库视图<a hidden class="anchor" aria-hidden="true" href="#1418-数据库视图">#</a></h3>
<p>数据库视图是<strong>虚拟表</strong>，作用：简化复杂查询、安全性、数据抽象、可重用性</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">employee_salaries</span><span class="w"> </span><span class="k">AS</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> 
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">    </span><span class="n">e</span><span class="p">.</span><span class="n">employee_id</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">    </span><span class="n">CONCAT</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">last_name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">full_name</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">    </span><span class="n">d</span><span class="p">.</span><span class="n">department_name</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">    </span><span class="n">e</span><span class="p">.</span><span class="n">salary</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> 
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">    </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w"></span><span class="k">JOIN</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">    </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">department_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">department_id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w"></span><span class="c1">-- CREATE VIEW view__ AS    
</span></span></span></code></pre></div><h3 id="1479-什么情况下不推荐为数据库建立索引">1479 什么情况下，不推荐为数据库建立索引<a hidden class="anchor" aria-hidden="true" href="#1479-什么情况下不推荐为数据库建立索引">#</a></h3>
<p>有以下几种情况：</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>原因</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>数据量小的表</td>
          <td>建议索引并不会显著提高查询性能，反而增加复杂性</td>
      </tr>
      <tr>
          <td>频繁更新的表</td>
          <td>每个插入删除操作，都需要更新索引，导致过高的维护索引的开销</td>
      </tr>
      <tr>
          <td>高度重复的列</td>
          <td>例如，性别，索引效果不明显，反而增加存储空间</td>
      </tr>
      <tr>
          <td>长文本字段</td>
          <td>这些类型的列包含大量数据，添加索引，导致无法使用内存排序，需要利用磁盘，导致大量IO</td>
      </tr>
  </tbody>
</table>
<h3 id="3179-数据库不停服迁移">3179 数据库不停服迁移<a hidden class="anchor" aria-hidden="true" href="#3179-数据库不停服迁移">#</a></h3>
<p>通过数据双写实现</p>
<ul>
<li>**旧数据同步：**采用主从同步方式，将新库作为旧库的从库，实现历史数据的迁移；</li>
<li>**新数据同步：**采用数据双写方式，将新数据同时写入新旧两个库中。</li>
<li>**一致性检查：**定时任务，抽检两个库的数据一致性；</li>
<li><strong>灰度切流：</strong> 逐渐将用户的数据请求，迁移到新库中。</li>
</ul>
<h3 id="4040-mysql数据库的性能优化方法">4040 MySQL数据库的性能优化方法<a hidden class="anchor" aria-hidden="true" href="#4040-mysql数据库的性能优化方法">#</a></h3>
<p>SQL 和 库表两部分设计，优化MySQL性能问题。</p>
<p><strong>SQL优化:</strong></p>
<ul>
<li>避免 SELECT * ，只查询必要字段；</li>
<li>避免在SQL中进行函数等计算操作，导致索引失效；</li>
<li>避免使用 %Like，导致全表扫描；</li>
<li>注意联合索引需要满足最左匹配原则；</li>
<li>不要对无索引字段进行排序。</li>
</ul>
<p><strong>库表设计</strong></p>
<ul>
<li>合理表结构：合理的数据类型；</li>
<li>合理冗余字段：冗余设计，减少关联查询；</li>
<li>索引优化：根据查询频率和条件，创建合适的索引；</li>
<li>分库分表：提高读写性能。</li>
</ul>
<hr>
<h3 id="1219-数据库三大范式">1219 数据库三大范式<a hidden class="anchor" aria-hidden="true" href="#1219-数据库三大范式">#</a></h3>
<p>第一范式：原子性，字段只包含单一数据项；</p>
<p>第二范式：非主键必须依赖于整个主键；</p>
<p>第三范式：非主键字段只依赖于主键，不应该相互依赖。</p>
<p>数据库中存储金额数据使用的数据类型：bigint and decimal</p>
<p>sql:java</p>
<p>bigint: long;</p>
<p>decimal:BigDecimal</p>
<h3 id="1482-mysql中exists和in的区别是什么">1482 MySQL中EXISTS和IN的区别是什么<a hidden class="anchor" aria-hidden="true" href="#1482-mysql中exists和in的区别是什么">#</a></h3>
<ul>
<li>EXISTS ɪɡˈzɪsts
<ul>
<li>判断子查询是否返回任何行，通常用于<strong>检查某个条件是否满足</strong>; 满足条件后则返回，大数据量时性能好</li>
</ul>
</li>
<li>IN
<ul>
<li>检查某个值是否在指定集合中；</li>
</ul>
</li>
</ul>
<p>EXISTS 外=&gt;内判断，满足即停止。最好子表有索引。</p>
<p>IN =&gt; 先内， 再外匹配内。</p>
<hr>
<h3 id="11175-sql中selectfrom-的执行顺序是什么">11175 SQL中SELECT、FROM&hellip; 的执行顺序是什么？<a hidden class="anchor" aria-hidden="true" href="#11175-sql中selectfrom-的执行顺序是什么">#</a></h3>
<ol>
<li>FROM</li>
<li>WHERE： 淘汰的单位是行</li>
<li>GROUP BY</li>
<li>HAVING：聚合数据，淘汰的单位是整组</li>
<li>SELECT</li>
<li>ORDER BY</li>
<li>LIMIT</li>
</ol>
<h3 id="b树聚簇索引主键索引二级索引">B+树、聚簇索引、主键索引、二级索引<a hidden class="anchor" aria-hidden="true" href="#b树聚簇索引主键索引二级索引">#</a></h3>
<p>B+树：数据结构</p>
<p>聚簇索引（主键索引）：叶子节点存储了整行数据，一张表只能有一张(Primary Key)。 使用B+树实现</p>
<p>二级索引：叶子和非叶子都只存储了Index比较需要的数据。使用B+树实现。因此，索引完，SELECT有其他字段，需要回表根据Primary Key再查一次</p>
<p>=&gt; 索引覆盖：将SELECT 所需的字段均放置在Index中，就不用回表查询了</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://121.40.252.207/tags/mysql/">MySQL</a></li>
    </ul>
  </footer> <div id="tw-comment"></div>
 <script>
     
     const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";
     const setGiscusTheme = () => {
         const sendMessage = (message) => {
             const iframe = document.querySelector('iframe.giscus-frame');
             if (iframe) {
                 iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "hhhey-lw\/LongWeiBlog",
            "data-repo-id": "R_kgDOOMaMvQ",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOOMaMvc4CoUI4",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "en",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
                ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://121.40.252.207/">LongCoding&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
