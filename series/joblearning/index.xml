<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JobLearning on LongCoding&#39;s Blog</title>
    <link>http://longcoding.top/series/joblearning/</link>
    <description>Recent content in JobLearning on LongCoding&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 13 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://longcoding.top/series/joblearning/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>集合面试题笔记</title>
      <link>http://longcoding.top/posts/jobs/collection/</link>
      <pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/collection/</guid>
      <description>&lt;h3 id=&#34;6319-hashmap-原理&#34;&gt;6319 HashMap 原理&lt;/h3&gt;&#xA;&lt;p&gt;数据结构：数组 + 链表  （JAVA8之后：数组+链表+红黑树）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据结构&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;jdk1.7：数组+链表，数组每个元素是一个链表的表头，当发生冲突，将新元素添加在头部(头插法)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;hash冲突：头插法，❗扩容时可能造成环形链表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;jdk1.8：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引入红黑树，当链表节点超过8个，那么这个链表会转换为红黑树。查询时间由 O(n) 优化为 O(logn)。当节点小于6个，再转换为链表。&lt;/li&gt;&#xA;&lt;li&gt;hash冲突：尾插法，避免环形链表❗&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;扩容机制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;jdk1.7&#xA;&lt;ul&gt;&#xA;&lt;li&gt;扩容，元素会重新计算hash值，并分配到新的扩容数组中。⭐比较耗时&lt;/li&gt;&#xA;&lt;li&gt;扩容时，头插法，在多线程情况下，可能造成环形链表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;jdk1.8&#xA;&lt;ul&gt;&#xA;&lt;li&gt;扩容时，利用了元素哈希值和旧数组容量关系，减少了重新计算的哈希次数&lt;/li&gt;&#xA;&lt;li&gt;扩容时，尾插法，避免环形链表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用键的&lt;code&gt;hashcode()&lt;/code&gt;计算hash值，然后(n-1) &amp;amp; hash确定数组中的位置。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;n-1 =&amp;gt; 10000 - 1 = 01111&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;HashMap的初始默认容量为16，负载因子为0.75。当存储的元素达到75%时，进行扩容，扩容为原来的2倍空间&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;扩展知识：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;hashmap的红黑树优化：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JAVA8开始，为了优化hash冲突时的查找性能。但链表的长度&lt;strong&gt;超过8&lt;/strong&gt;时，链表会转变为红黑树。红黑树是一种自平衡的二叉搜索树 查找时间 O(n) =&amp;gt; O(logn)。 当元素少于6个，切换为链表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;hashCode() 和 equals()的重要性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;hashCode计算hash值，决定键的存储位置。 而hashCode相同=&amp;gt;冲突。 equals()比较的值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// HashMap Node class&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Entry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 键&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 计算后的哈希值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 指向下一个元素的指针（形成链表）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;为什么头插法&amp;amp;多线程&amp;amp;扩容会造成环形链表?&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM面试题笔记</title>
      <link>http://longcoding.top/posts/jobs/jvm/</link>
      <pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/jvm/</guid>
      <description>&lt;h3 id=&#34;521-java如何实现跨平台的&#34;&gt;521. Java如何实现跨平台的？&lt;/h3&gt;&#xA;&lt;p&gt;Java编译生成的是字节码文件.class文件，而不是特定于某个操作系统的机器码。&lt;/p&gt;&#xA;&lt;p&gt;不同操作系统上都有各自实现的JVM，负责将字节码翻译成特定平台的机器代码并执行。使得JAVA文件可以被不同操作系统上的JVM运行。包装了一层。&lt;/p&gt;&#xA;&lt;h3 id=&#34;9807-jvm的组成部分&#34;&gt;9807. JVM的组成部分&lt;/h3&gt;&#xA;&lt;p&gt;主要组成部分：&lt;/p&gt;&#xA;&lt;p&gt;编译好的JAVA字节码（.class文件）准备就绪。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类加载器子系统：将class文件加载到内存中(运行时的数据区)。&lt;/li&gt;&#xA;&lt;li&gt;运行时数据区。&lt;/li&gt;&#xA;&lt;li&gt;执行引擎(命令解释器)：将字节码文件翻译成机器码，并交给CPU执行；&lt;/li&gt;&#xA;&lt;li&gt;本地方法接口：过程中会调用不同语言提供的接口，比如驱动和..，调用本地方法接口，例如操作系统级别的功能或者高性能库。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;http://verification.longcoding.top/FtrSjvLjXEixufKxk9avjPMmQNpg&#34; alt=&#34;image-20250314162756632&#34; style=&#34;zoom:50%;&#34; /&gt;&#xA;&lt;h3 id=&#34;522-编译执行和解释执行&#34;&gt;522. 编译执行和解释执行&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;编译执行&lt;/strong&gt;&lt;/em&gt;：先将源代码编译为机器代码，再在CPU上运行。例如：C，C++；&lt;/p&gt;&#xA;&lt;p&gt;​&#x9;啊&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点：编译后运行速度快，并且运行时，不需要再进行翻译。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;解释执行&lt;/strong&gt;&lt;/em&gt;：运行时，解释器逐行翻译并执行例如Python。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;跨平台性好， 每个代码都是在每个平台上通过相应平台的解释器运行。&lt;/li&gt;&#xA;&lt;li&gt;速度慢，每次执行都需要动态翻译。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;=&amp;gt; Java采样编译执行和解释执行相结合的方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解释执行：JVM将.JAVA文件=&amp;gt;.class字节码。 有助于程序的跨平台性；&lt;/li&gt;&#xA;&lt;li&gt;即时编译：将经常执行的代码编译为本地机器码，避免反复解释&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;523-jvm的内存区域如何划分的&#34;&gt;523. JVM的内存区域如何划分的❗?&lt;/h3&gt;&#xA;&lt;p&gt;JVM运行时的数据区分为：1. &lt;strong&gt;方法区&lt;/strong&gt; 2. &lt;strong&gt;堆&lt;/strong&gt; 3. &lt;strong&gt;虚拟机栈&lt;/strong&gt; 4. &lt;strong&gt;本地方法栈&lt;/strong&gt; 5. 程序计数器。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;方法区&lt;/strong&gt; - 存储类&amp;amp;共享信息&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储类信息、常量、静态变量&lt;/li&gt;&#xA;&lt;li&gt;这些信息属于线程共享区域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Java&lt;strong&gt;堆&lt;/strong&gt; - 与JVM共存亡&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存放所有线程共享的对象实例 和 数组 (垃圾回收主要战地)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚拟机&lt;strong&gt;栈&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;每个线程&lt;/strong&gt;创建一个栈：用来保存&lt;strong&gt;局部变量&lt;/strong&gt;、&lt;strong&gt;操作数栈&lt;/strong&gt;、方法出口信息。&lt;/li&gt;&#xA;&lt;li&gt;局部变量：基本数据类型；以及对象引用；&lt;/li&gt;&#xA;&lt;li&gt;栈与线程共存亡&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地方法栈&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为本地方法服务。。。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;程序计数器&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保存&lt;strong&gt;当前线程&lt;/strong&gt;执行的字节码指令地址或行号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://verification.longcoding.top/FirLgeEVeLb4N108rU7mpuX1BdPY&#34; alt=&#34;image-20250314165936676&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;总结java程序与线程在jvm内存中的流程&#34;&gt;总结：Java程序与线程在JVM内存中的流程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;程序启动&lt;/strong&gt;：JVM初始化内存区域，加载&lt;strong&gt;类信息&lt;/strong&gt;到&lt;strong&gt;方法区&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;线程创建&lt;/strong&gt;：为&lt;strong&gt;线程&lt;/strong&gt;分配&lt;strong&gt;程序计数器&lt;/strong&gt;、Java虚拟机&lt;strong&gt;栈&lt;/strong&gt;和本地方法&lt;strong&gt;栈&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;方法调用&lt;/strong&gt;：&lt;strong&gt;线程&lt;/strong&gt;执行方法时，&lt;strong&gt;创建栈帧并压入Java虚拟机栈&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;对象创建&lt;/strong&gt;：&lt;strong&gt;对象实例存储在Java堆中&lt;/strong&gt;，元数据存储在方法区。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;：JVM清理不再使用的对象和类信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;线程结束&lt;/strong&gt;：线程的栈和程序计数器被销毁。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;程序结束&lt;/strong&gt;：JVM释放所有内存区域并退出。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;524-jvm中堆和栈的区别是什么&#34;&gt;524. JVM中堆和栈的区别是什么？&lt;/h3&gt;&#xA;&lt;p&gt;栈：主要用于&lt;strong&gt;存储局部变量(基本类型+对象引用)和方法的调用信息(返回地址、参数等)&lt;/strong&gt;。线程执行时，会创建该线程的栈帧，被压入Java虚拟机栈中。 执行结束，线程栈帧被弹出(销毁)&lt;/p&gt;</description>
    </item>
    <item>
      <title>并发面试题笔记</title>
      <link>http://longcoding.top/posts/jobs/juc/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/juc/</guid>
      <description>&lt;h3 id=&#34;1-如何创建线程&#34;&gt;1 如何创建线程&lt;/h3&gt;&#xA;&lt;p&gt;1） 实现&lt;strong&gt;Runnable&lt;/strong&gt;接口&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现run()方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyRunnable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2）继承Thread类&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重写run()方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;3）&lt;strong&gt;Callable接口&lt;/strong&gt;&amp;amp;&amp;amp;FutureTask&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现Callable call()方法，使用FutureTask包装Callable对象，通过Thread启动&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;FutrueTask&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ReturnType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FutrueTask&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyCallable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ResultType&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这里阻塞&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4）使用线程池&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过ExecutorService提交Runnable或者Callable任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不同方法对比&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vs&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Callable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;Callable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;可以返回结果&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;可以抛出异常&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;线程池的优势&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;避免重复创建和销毁线程&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;减少这部分重复带来的开销&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ThreadPool&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FixedThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CachedThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ScheduledThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;虚拟线程&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;虚拟线程创建和切换开销更低&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;startVirtualThread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;ThreadPool实践&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;XXXThreadPool.submit(task&amp;hellip;)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;FixedThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;固定池中线程数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;适合1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;执行较长任务&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;控制并发度&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CachedThreadPool&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;池中线程数量不固定&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;根据需要动态创建线程&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;空的被回收&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;少了多创建&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;⭐&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;适用于任务执行时间短且任务数量不确定的场景&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ScheduledThreadPool&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;适用于需要定时执行或周期性执行任务的场景&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 定时任务线程池&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ScheduledExecutorService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;scheduledThreadPool&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Executors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newScheduledThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// For 延迟任务&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;scheduledThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;schedule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 任务逻辑&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TimeUnit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SECONDS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 延迟10秒执行&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// For周期执行任务&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;scheduledThreadPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;scheduleAtFixedRate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 任务逻辑&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TimeUnit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SECONDS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 每隔1秒执行一次&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Thread.sleep(0) &amp;lt;= 主动让出CPU控制权&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL面试题笔记</title>
      <link>http://longcoding.top/posts/jobs/mysql/</link>
      <pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/mysql/</guid>
      <description>&lt;h3 id=&#34;617-mysql-数据排序-实现&#34;&gt;617 MySQL 数据排序 实现？&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Order By 命中索引(包括索引字段)，使用索引排序(&lt;strong&gt;⭐有序⭐&lt;/strong&gt;)，效率最高效&lt;/li&gt;&#xA;&lt;li&gt;否则使用文件排序，文件少=&amp;gt; 内存排序 sort_buffer&lt;/li&gt;&#xA;&lt;li&gt;文件大=&amp;gt;外部排序，归并排序&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;内部排序细节：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;双路排序(待排序的列数据太大了)&lt;/strong&gt;：使用row_id(回查表) + sort_field&lt;/p&gt;&#xA;&lt;p&gt;​&#x9;&#x9;排好序后，使用row_id将完整的记录取出来&lt;/p&gt;&#xA;&lt;p&gt;单路排序(待排序数据大小能接受)&lt;/p&gt;&#xA;&lt;p&gt;​&#x9;直接拍，不会查表，直接把拍好的结果返回&lt;/p&gt;&#xA;&lt;p&gt;外部排序：&lt;/p&gt;&#xA;&lt;p&gt;拆分小的，外部多路归并排序，小=&amp;gt;大&lt;/p&gt;&#xA;&lt;p&gt;外部归并排序 =&amp;gt; 先分段排序，每一段调入内存执行快排&lt;/p&gt;&#xA;&lt;p&gt;​                        =&amp;gt; 归并阶段，因为每子段都是有序的 =&amp;gt; 多路归并排序&lt;/p&gt;&#xA;&lt;h3 id=&#34;589-一条sql的执行过程&#34;&gt;589 一条SQL的执行过程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;先通过&lt;strong&gt;连接器&lt;/strong&gt;校验权限&lt;/li&gt;&#xA;&lt;li&gt;利用&lt;strong&gt;分析器&lt;/strong&gt;进行SQL语句词法分析和语法分析，构建解析树&lt;/li&gt;&#xA;&lt;li&gt;利用&lt;strong&gt;优化器&lt;/strong&gt;选择合适的索引和表连接顺序，最终选择一条最佳的执行计划&lt;/li&gt;&#xA;&lt;li&gt;利用&lt;strong&gt;执行器&lt;/strong&gt;，调用引擎层查询数据，返回结果集&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;具体：Select * from user where id = 1;&lt;/p&gt;&#xA;&lt;img src=&#34;http://verification.longcoding.top/FssKKPCKzeVJv4TEPdMldct1M8z4&#34; alt=&#34;image-20250305222939319&#34; style=&#34;zoom:50%;&#34; /&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SQL =&amp;gt; Server层&lt;strong&gt;连接器&lt;/strong&gt;，权限校验，账号是否有资格获取。无=&amp;gt; Access denied for user。  连接成功后，空闲一段时间会断开&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;分析器(查询解析)&lt;/strong&gt; =&amp;gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语法分析：SQL  : Select类型✔️ user表✔️ id列 ✔️拆分成词，再组装为解析树。&lt;/li&gt;&#xA;&lt;li&gt;语义分析：语法是否有误 =&amp;gt; you have an error in your SQL syntax (字段、表|存在？)   分析解析树语法正确性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;优化器&lt;/strong&gt;(查询优化)=&amp;gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis面试题笔记</title>
      <link>http://longcoding.top/posts/jobs/redis/</link>
      <pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/redis/</guid>
      <description>&lt;h3 id=&#34;637-常见的数据类型&#34;&gt;637 常见的数据类型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;String&lt;/li&gt;&#xA;&lt;li&gt;Set&lt;/li&gt;&#xA;&lt;li&gt;Hash&lt;/li&gt;&#xA;&lt;li&gt;List&lt;/li&gt;&#xA;&lt;li&gt;Zset （Sorted Set）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;BitMap =&amp;gt; 位图，考勤，或者xxx分配情况&lt;/p&gt;&#xA;&lt;p&gt;HyperLogLog =&amp;gt; 用户访问的独立用户数量&lt;/p&gt;&#xA;&lt;p&gt;GEO =&amp;gt; 地理&lt;/p&gt;&#xA;&lt;p&gt;应用场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缓存&lt;/li&gt;&#xA;&lt;li&gt;实时系统&lt;/li&gt;&#xA;&lt;li&gt;消息队列&lt;/li&gt;&#xA;&lt;li&gt;分布式锁&lt;/li&gt;&#xA;&lt;li&gt;计数器：页面访问量、点赞数、评论数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;651-redis-主从复制的实现原理&#34;&gt;651 Redis 主从复制的实现原理&lt;/h3&gt;&#xA;&lt;p&gt;➡️主节点-从节点 的数据同步&lt;/p&gt;&#xA;&lt;p&gt;Why 需要主和从&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据冗余&amp;amp;故障恢复，某个节点宕机了，但是其他节点还活着；&lt;/li&gt;&#xA;&lt;li&gt;提供负载均衡，配合读写分离策略，主节点写操作，从节点提供读操作；&lt;/li&gt;&#xA;&lt;li&gt;高可用：主从复制是Redis的高可用的基础，也是哨兵和集群实施的基础。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;复制流程： 全量 &amp;amp; 增量&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主节点发送SYNC命令与从节点进行连接，开始同步， 主从之间建立联系；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;全量复制(第一次连接)： 主节点把全部数据复制到从节点，主节点将当前数据生成RDB文件，发送给从节点；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;发送的期间，主节点缓存(Replication backlog buffer-复制积压缓冲区)所有写命令。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;发送缓存的写命令给从节点。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;持续同步，持续把写命令同步给从节点。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;保持连接与断线重连&lt;/p&gt;&#xA;&lt;p&gt;Redis中，主节点会和从节点保持长连接，以确保数据的持续同步；&lt;/p&gt;&#xA;&lt;p&gt;当连接断开后，重连，请求增量复制，避免全量复制带来的大量开销。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据一致性和复制延迟&lt;/p&gt;&#xA;&lt;p&gt;由于网络延迟，主从之间会存在短暂的数据不一致。 ⭐对于数据一致性严格的任务，要求访问主节点。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;652-redis集群实现的原理&#34;&gt;652 Redis集群实现的原理&lt;/h3&gt;&#xA;&lt;p&gt;➡️通过多个Redis实例实现，每个实例存储部分数据，且这些数据是不重复的。&lt;strong&gt;类似于将数据库分库，按业务功能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;➡️具体为采用Hash Slot哈希槽，将键的空间划分为16384个槽。每个Redis实例只负责一部分槽。&lt;/p&gt;&#xA;&lt;p&gt;客户端 =&amp;gt; 任意Redis实例 =&amp;gt; 数据是否在本机上，在返回，否则返回目标节点信息，客户端再路由到其他Redis中。&lt;/p&gt;&#xA;&lt;p&gt;&amp;lt;= 将单个Redis的压力，分摊到多台Redis实例上，提高并发性能。&lt;/p&gt;&#xA;&lt;p&gt;特性&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现数据分布式存储，对数据进行分片，将不同数据储存在不同节点中&lt;/li&gt;&#xA;&lt;li&gt;去中心化思想，无中心节点，访问任意一个即可。访问正确则响应数据，否则响应对应的节点信息，客户端再次访问。&lt;/li&gt;&#xA;&lt;li&gt;内置高可用性：分为N组，每组提供不同的数据缓存服务，每组中又有一个主节点和K个从节点(主提供读写，从提高读，并进行数据同步功能)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://verification.longcoding.top/Fo9jCIPyRQ866mnZdasVsUwqao1j&#34; alt=&#34;image-20250307175456538&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring笔记</title>
      <link>http://longcoding.top/posts/jobs/spring/</link>
      <pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/spring/</guid>
      <description>&lt;h3 id=&#34;1-什么是循环依赖&#34;&gt;1. 什么是循环依赖&lt;/h3&gt;&#xA;&lt;p&gt;两个及以上的类之间相互依赖。模块A依赖于模块B，模块B依赖于模块A，导致依赖链的循环，无法确定加载/初始化顺序。&lt;/p&gt;&#xA;&lt;p&gt;=&amp;gt; 多个Bean循环引用导致Spring容器无法正常初始化它们。&lt;/p&gt;&#xA;&lt;p&gt;延迟某些Bean的初始化时间，使用@Lazy进行懒加载，只有当实际使用了该对象才创建。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-spring如何解决循环依赖&#34;&gt;2. Spring如何解决循环依赖&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;提前暴露未完全创建的Bean&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;三级缓存解决：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一级缓存(Single Objects Map)：用于初始化单例Bean； (成品)&lt;/li&gt;&#xA;&lt;li&gt;二级缓存(Early Singleton Objects Map): 用于存储尚未完全初始化，但实例化的Bean，用于提取暴露对象，避免循环依赖问题；(半成品，成员变量未初始化)&lt;/li&gt;&#xA;&lt;li&gt;三级缓存(Singleton Factories Map): 用于存储对象工厂，可以通过工厂创建早期Bean&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;**解决步骤：**例如AB两个相互依赖，三级缓存策略&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建A，查询一级缓存看看有没有完全体B，没有则看看二级缓存有没有半成品B，都没有则创建A的Bean，调用ceateBean方法(实例化，属性注入，初始化)；&lt;/li&gt;&#xA;&lt;li&gt;之后，A往&lt;strong&gt;三级缓存&lt;/strong&gt;加入一个A的getObject方法&lt;/li&gt;&#xA;&lt;li&gt;到了属性注入，因为A依赖B，那么需要创建B。同样的路线，B查询到二级缓存都没发现A，调用createBean创建B实例。到了B的属性注入，发现三级缓存有A工厂，调用getObject创建半成品A，放到二级缓存中，完成B的第二步属性注入。后面initializeBean完成B的创建，并放到一级缓存中。&lt;/li&gt;&#xA;&lt;li&gt;回到A，A调用一级缓存的B完成注入。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;未解决的问题：&lt;/p&gt;&#xA;&lt;p&gt;而如果说 A 是构造器注入，B 是 set 注入。则说明 A 需要 B 的时刻提前了，在实例化 new A(B b)的时候就需要 B。此时 A 没有往三级缓存放getObject，因此到了创建依赖 B的时候，无法获取 A的 getObject 工厂方法，只能继续 new A，造成循环依赖的死循环。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-spring重要的模块组成&#34;&gt;4. Spring重要的模块组成&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Core Container 核心容器：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring Core：提供依赖注入DI和控制反转IOC的实现。&lt;/li&gt;&#xA;&lt;li&gt;Spring Beans：负责管理Bean的定义和生命周期，通过IOC完成Bean的创建、依赖注入、初始化、销毁等操作；&lt;/li&gt;&#xA;&lt;li&gt;Spring Context：基于Core和Beans的高级容器，提供类似JNDI的上下文功能，包含国际化、事件传播、资源访问等功能；&lt;/li&gt;&#xA;&lt;li&gt;Spring Expression Language：用于运行时查询和操作对象的值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;AOP面向切面编程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Spring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的业务逻辑。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Data Access 数据访问&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java面试题笔记</title>
      <link>http://longcoding.top/posts/jobs/java/</link>
      <pubDate>Wed, 19 Feb 2025 00:00:00 +0000</pubDate>
      <guid>http://longcoding.top/posts/jobs/java/</guid>
      <description>&lt;h3 id=&#34;415-序列化反序列化&#34;&gt;415 序列化&amp;amp;反序列化&lt;/h3&gt;&#xA;&lt;p&gt;将Object转为字节流，或反之&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;普通：实现serializable接口 ˈsɪərɪəlaɪzəbl&lt;/li&gt;&#xA;&lt;li&gt;使用Jackon，Obj =&amp;gt; json格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;416-java中的不可变类&#34;&gt;416 Java中的不可变类&lt;/h3&gt;&#xA;&lt;p&gt;final 修饰，例如String类&lt;/p&gt;&#xA;&lt;p&gt;🎉优点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程安全&lt;/li&gt;&#xA;&lt;li&gt;缓存友好&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缺点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;性能问题，因为不能修改，所有每次状态变化，都需要生成新的对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;411-多态特性&#34;&gt;411 多态特性&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;继承&lt;/li&gt;&#xA;&lt;li&gt;方法重载，函数名相同，但是函数签名需要有差异(参数类型&amp;amp;数量)&lt;/li&gt;&#xA;&lt;li&gt;重写，子类重写父类方法，通过父类调用方法时，调用的是子类重写后的函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;412-java参数传值是副本还是引用呢&#34;&gt;412 Java参数传值是副本还是引用呢？&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本类型是传&lt;strong&gt;值副本&lt;/strong&gt;，int&amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;引用数据类型是传&lt;strong&gt;引用副本&lt;/strong&gt;。 including：obj，array&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;425-java中-包装类型和基本类型&#34;&gt;425 Java中 包装类型和基本类型&lt;/h3&gt;&#xA;&lt;p&gt;🏷️基本类型 =&amp;gt; int long float double  &amp;hellip;  位于栈上(局部变量的话) ，性能好，但&lt;strong&gt;不支持为null&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;（局部变量在栈上，成员变量在堆上，静态字段在方法区）&lt;/p&gt;&#xA;&lt;p&gt;🏷️包装类型 =&amp;gt; 每一个基本类型都对应一个包装类型。&lt;strong&gt;包装类型是类，在堆中，支持null&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;JVM内存模型&lt;/strong&gt;  ❗❗❗内存堆和数据结构堆不是同一个东西(不是堆的结构)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;+--------------------------------------------+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;               &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;方法区&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Area&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;←&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;线程共享&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;类元数据&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;信息&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                   &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;静态变量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;变量&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;常量池&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;字符串常量等&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                   &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+--------------------------------------------+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;↑&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;↑&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+----------------+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+-----------------+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;栈&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Stack&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;堆&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Heap&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;←&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;线程共享&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;局部变量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Java&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;对象实例&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;方法调用栈&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;数组&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+----------------+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+-----------------+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;413-interface--abstract-class&#34;&gt;413 interface &amp;amp; abstract class&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;interface(自上而下) 知晓某一种行为，基于这些行为约束定义的接口， 一些类需要有这些行为的话，需要实现这些接口&lt;/li&gt;&#xA;&lt;li&gt;abstract class(自下而上): 有许多类，它们有共同点，很多代码可以复用，因此将公共逻辑封装为抽象对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;100-hashcode--equals--&#34;&gt;100 hashCode &amp;amp; equals &amp;amp; ==&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;hashCode用于散列表(hashMap)用于计算hash值，从而计算存储位置；&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
